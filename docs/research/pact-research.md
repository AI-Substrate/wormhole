Below is a practical, copy‑pasteable guide to using **Pact** to validate contracts for HTTP APIs and event/message interfaces, with examples across JSON, XML, and Protobuf/gRPC. It closes with a quality playbook you can adopt in CI/CD.

---

## 1) What Pact is, why it exists, and why it’s great

**Pact** is a *consumer‑driven contract testing* framework. A consumer writes executable tests that describe what it needs from a provider (API or message producer). Passing those tests produces a **contract** (a “pact” file). Providers then **verify** they still satisfy that contract. This replaces large, brittle end‑to‑end tests with fast, precise checks at the service boundary. Benefits include faster deploys, fewer integration surprises, and “safety gates” that block incompatible releases. ([Pact Docs][1])

**Key ideas (you’ll see these terms below):**

* **Consumer / Provider** — the client and the service being called (or the message producer/consumer for async systems). ([Pact Docs][1])
* **Interactions** — request/response (HTTP) or messages (async).
* **Pact file** — JSON contract generated by consumer tests.
* **Provider states** — deterministic set‑up hooks the provider exposes to make verifications repeatable (e.g., “user 42 exists”). ([Pact Docs][2])
* **Pact Broker** — stores contracts + verification results and powers **can‑i‑deploy** checks before release. ([Pact Docs][3])
* **Matching rules** — expressive type/shape matchers that make tests robust (e.g., “an integer”, “an ISO‑8601 timestamp”) rather than fragile exact values. ([Pact Docs][4])
* **Plugins (Spec V4)** — extend Pact beyond HTTP/JSON to transports like gRPC and content types like Protobuf, CSV, XML, etc. ([Pact Docs][5])

---

## 2) Install the tooling (by language)

> Pick the language(s) you use. You can mix languages across consumer/provider—Pact is designed for that.

### JavaScript/TypeScript (Pact JS)

```bash
npm install --save-dev @pact-foundation/pact
# Optional CLI helpers (publish, can-i-deploy etc.)
npm install --save-dev @pact-foundation/pact-cli
```

Node 16+ for recent versions. ([Pact Docs][6])

### Java / JVM (JUnit 5)

**Consumer tests**:

```xml
<dependency>
  <groupId>au.com.dius.pact.consumer</groupId>
  <artifactId>junit5</artifactId>
  <version>4.4.x</version>
  <scope>test</scope>
</dependency>
```

([Pact Docs][7])

**Provider verification**:

```xml
<dependency>
  <groupId>au.com.dius.pact.provider</groupId>
  <artifactId>junit5</artifactId>
  <version>4.6.x</version>
  <scope>test</scope>
</dependency>
```

([Pact Docs][8])

### Python

```bash
pip install pact-python
```

pact‑python provides HTTP and (v3+) asynchronous message support. ([PyPI][9])

### .NET (C#) — PactNet

```bash
dotnet add package PactNet
```

PactNet supports Spec V4 (excluding plugins). ([NuGet][10])

### Pact Broker & CLI (all stacks)

* **Broker (Docker)**:

  ```bash
  docker run -p 9292:9292 \
    -e PACT_BROKER_DATABASE_URL=postgres://... \
    pactfoundation/pact-broker:latest
  ```

  (Requires Postgres. Use PactFlow if you prefer SaaS.) ([Pact Docs][11])
* **Broker/Verifier CLI**: use the `pactfoundation/pact-cli` image (or the native verifier binary) in CI. ([Pact Docs][12])

---

## 3) Quick start (HTTP/JSON)

### 3.1 Consumer test → generates the contract (JS)

```ts
// test/animals.pact.spec.ts
import path from 'node:path'
import { PactV3, MatchersV3 } from '@pact-foundation/pact'

const provider = new PactV3({
  consumer: 'WebApp',
  provider: 'AnimalService',
  dir: path.resolve(process.cwd(), 'pacts'),
})

describe('GET /animals/:id', () => {
  it('returns an animal (JSON)', async () => {
    await provider
      .given('animal with id 42 exists')
      .uponReceiving('a request for animal 42')
      .withRequest({
        method: 'GET',
        path: '/animals/42',
        headers: { Accept: 'application/json' },
      })
      .willRespondWith({
        status: 200,
        headers: { 'Content-Type': 'application/json' },
        body: {
          id: MatchersV3.integer(42),
          name: MatchersV3.string('Spot'),
          adoptedAt: MatchersV3.timestamp("yyyy-MM-dd'T'HH:mm:ss.SSSX"),
        },
      })
      .executeTest(async (mock) => {
        // call your real client against mock.url
        const res = await fetch(`${mock.url}/animals/42`, {
          headers: { Accept: 'application/json' },
        })
        const json = await res.json()
        if (json.id !== 42) throw new Error('Bad id')
      })
  })
})
```

This produces `pacts/WebApp-AnimalService.json` with type‑safe **matching rules** instead of brittle literals. ([Pact Docs][13])

### 3.2 Provider verification (JS)

```js
// test/pact.verify.test.js
const { Verifier } = require('@pact-foundation/pact')

test('verifies against all relevant consumer contracts', async () => {
  const opts = {
    providerBaseUrl: 'http://localhost:8081',        // your running API
    provider: 'AnimalService',
    pactBroker: process.env.PACT_BROKER_URL,         // or pactUrls: [local pact file]
    pactBrokerToken: process.env.PACT_BROKER_TOKEN,
    consumerVersionSelectors: [
      { matchingBranch: true },                      // verify branch-matching pacts
      { deployedOrReleased: true },                  // and what’s in prod
    ],
    enablePending: true,                             // don’t fail on first-seen pacts
    includeWipPactsSince: '2024-01-01',
    publishVerificationResult: true,
    providerVersion: process.env.GIT_SHA,
    providerVersionBranch: process.env.BRANCH_NAME,
    stateHandlers: {
      'animal with id 42 exists': () => seedAnimal(42),
    },
  }

  await new Verifier(opts).verifyProvider()
})
```

Notes:

* **stateHandlers** initialize provider data for each interaction (deterministic tests).
* **selectors + pending/WIP** keep providers green while still verifying new work. ([Pact Docs][14])

---

## 4) Publish contracts and gate releases

### 4.1 Publish the pact (JS)

```jsonc
// package.json
{
  "scripts": {
    "pact:publish": "pact-broker publish ./pacts \
      --consumer-app-version=\"$(npx absolute-version)\" \
      --auto-detect-version-properties \
      --broker-base-url=$PACT_BROKER_URL"
  }
}
```

(Add `PACT_BROKER_TOKEN` in CI.) ([Pact Docs][13])

### 4.2 Block unsafe deploys with **can‑i‑deploy**

```bash
# After you publish or verify, record deployments:
pact-broker record-deployment \
  --pacticipant AnimalService --version "$GIT_SHA" --environment production

# Before deploying:
pact-broker can-i-deploy \
  --pacticipant AnimalService --version "$GIT_SHA" \
  --to-environment production --broker-base-url "$PACT_BROKER_URL"
```

If the broker’s matrix shows incompatibilities with what’s already in the target environment, this exits non‑zero and your pipeline stops. ([Pact Docs][3])

---

## 5) More than JSON: variety of interfaces

### 5.1 XML over HTTP (JS)

Pact JS includes an `XmlBuilder` so you can contract on XML payloads with matchers/generators:

```ts
import { PactV3, XmlBuilder, MatchersV3 } from '@pact-foundation/pact'

await provider
  .uponReceiving('request for projects (XML)')
  .withRequest({ method: 'GET', path: '/projects', headers: { Accept: 'application/xml' } })
  .willRespondWith({
    status: 200,
    headers: { 'Content-Type': 'application/xml' },
    body: new XmlBuilder('1.0','UTF-8','ns1:projects').build((el) => {
      el.setAttributes({ 'xmlns:ns1': 'http://example/ns' })
      el.eachLike('ns1:project', {
        id: MatchersV3.integer(1),
        name: MatchersV3.string('Project 1'),
      }, (project) => {
        project.appendElement('ns1:tasks', {}, (task) => {
          task.eachLike('ns1:task', {
            id: MatchersV3.integer(1),
            done: MatchersV3.boolean(true),
          })
        })
      }, { examples: 2 })
    }),
  })
  .executeTest(/* ... */)
```

([Pact Docs][15])

### 5.2 Asynchronous messages (queues, topics) — Python example

For event‑driven systems, you contract on the **message content**, not the transport.

**Consumer message test** (defines the expected payload and exercises your handler):

```py
# tests/test_delete_user_message.py
import json
from pact import Pact
from my_consumer import process_message

def handler(body, metadata):
    message = json.loads(body)
    process_message(message)

pact = Pact(consumer="deleteUserService", provider="userEvents").with_specification("V3")
(
  pact
  .upon_receiving("a request to delete a user", "Async")
  .with_body(json.dumps({"action": "delete_user", "user_id": "123"}))
)

def test_message():
    pact.verify(handler, "Async")
```

The provider test triggers the producer to emit the message and Pact asserts the payload matches the contract. ([Pact Foundation][16])

### 5.3 Protobuf / gRPC with Pact **plugins**

Use the **Protobuf/gRPC plugin** to contract‑test binary schemas and RPC methods (Pact Spec V4).

**High‑level steps (JVM/Go/JS vary slightly):**

1. Install plugin (`pact-plugin-cli` or via your language runtime), e.g. `protobuf` plugin.
2. In your consumer test, **load the plugin** and configure the interaction with your `.proto`, service/method, and matching rules for fields.
3. Run provider verification with the plugin enabled; it spins up a gRPC‑aware mock/verification flow.

Example projects and the plugin README show exact flags/keys and code snippets. ([GitHub][17])

---

## 6) JVM samples (optional)

**Consumer (JUnit 5):**

```java
@Pact(provider="ArticlesProvider", consumer="ArticlesConsumer")
public V4Pact pact(PactDslWithProvider builder) {
  return builder
    .given("test state")
    .uponReceiving("get articles")
      .path("/articles.json").method("GET")
    .willRespondWith().status(200).body("{\"ok\":true}")
    .toPact(V4Pact.class);
}

@PactConsumerTest
@PactTestFor(providerName = "ArticlesProvider")
class ArticlesConsumerTest { /* inject MockServer and call it */ }
```

([Pact Docs][7])

**Provider verification (JUnit 5):**

```java
@Provider("ArticlesProvider")
@PactFolder("pacts") // or @PactBroker(...)
class ContractVerificationTest {
  @BeforeEach
  void before(PactVerificationContext context) {
    context.setTarget(HttpTestTarget.fromUrl(new URL(System.getenv("PROVIDER_URL"))));
  }

  @TestTemplate
  @ExtendWith(PactVerificationInvocationContextProvider.class)
  void pactVerification(PactVerificationContext context) {
    context.verifyInteraction();
  }
}
```

Supports **consumer version selectors** (branch, environment, etc.) when reading from a Broker. ([Pact Docs][8])

---

## 7) Driving quality with Pact (playbook)

Adopt these practices to get maximum signal and minimum flakiness:

1. **Design contracts around behavior, not examples**
   Use **matchers** (type/regex/date/array) generously, avoid over‑specifying values. Treat the pact as a schema plus examples. ([Pact Docs][4])

2. **Use provider states** consistently
   Seed data via **provider states**; don’t depend on shared test databases. Name states in the consumer and implement them once on the provider. ([Pact Docs][2])

3. **Verify the right set of pacts**
   Pull exactly what matters with **consumer version selectors** (e.g., `matchingBranch`, `mainBranch`, `deployedOrReleased`). This keeps providers compatible with current prod and in‑flight branches without verifying obsolete contracts. ([Pact Docs][8])

4. **Enable Pending & WIP pacts**
   Turn on `enablePending` and `includeWipPactsSince` so *new* contracts don’t break provider builds while still being verified and fed back to consumers. ([Pact Docs][14])

5. **Automate the “safety gates”**

   * Publish consumer pacts on every change.
   * Publish provider verification results on every build.
   * Before any deploy, run **`can-i-deploy`** for the exact version and target environment; fail the pipeline if incompatible.
   * After deploy, **record** the deployment so the Broker’s matrix stays accurate. ([Pact Docs][3])

6. **Use the right transport/content support**
   For JSON/HTTP, use native libraries. For XML, adopt Pact JS’s `XmlBuilder`. For gRPC/Protobuf (and other protocols), use **plugins** under Spec V4. Check examples and feature support before choosing a stack. ([Pact Docs][15])

7. **Keep contracts small and focused**
   One interaction per scenario, minimal fields, stable identifiers via `fromProviderState`/generators when needed. (See “matching” and provider state injected values.) ([Pact Docs][4])

8. **Trigger verifications on change**
   Use Broker **webhooks** so when a new pact is published, the provider build runs automatically and pushes results back. ([Pact Docs][18])

9. **Treat the Broker as your source of truth**
   Host it (Docker) or use PactFlow; use read‑only tokens locally and read/write in CI. ([Pact Docs][11])

---

## 8) Typical CI/CD stages (outline)

1. **Consumer pipeline**

   * Run unit + Pact consumer tests → generate pacts
   * `pact-broker publish …` with app version (e.g., Git SHA)
   * (Optional) notify provider via Broker webhook

2. **Provider pipeline**

   * Start provider with dependencies stubbed
   * Fetch pacts from Broker using **selectors** and **pending/WIP** flags
   * Run verification; **publish results** with provider version + branch
   * Gate deploy with **can‑i‑deploy**
   * Deploy; **record-deployment** in Broker

These steps (selectors, pending, can‑i‑deploy, record‑deployment) are the backbone of a robust contract‑testing program. ([Pact Docs][14])

---

## 9) Reference snippets you’ll reuse

**Matchers (JS):**

```ts
import { Matchers } from '@pact-foundation/pact'
const { like, integer, boolean, timestamp, regex, eachLike } = Matchers
```

Examples and full catalog live in the Pact JS matching guide. ([Pact Docs][4])

**State handlers (JS provider):**

```js
stateHandlers: {
  'user 42 exists': (params) => seedUser(42),
  'is authenticated': () => { token = issueToken() },
}
```

([Pact Docs][14])

**Broker auth token guidance (PactFlow):** use bearer tokens (not basic auth) for publishing/verifying from CI. ([PactFlow Documentation][19])

---

## 10) Troubleshooting pointers

* **“Why did verification fail?”** Inspect the mismatch report in the verifier output; it highlights the exact field/shape that didn’t match.
* **“My provider needs dynamic IDs.”** Use `fromProviderState` (JS) or provider state params (JVM) so the consumer can assert shapes while the provider supplies runtime values. ([Pact Docs][4])
* **“I’m not seeing all pacts verified.”** Check your **selectors** and whether `pending`/`WIP` or `tags/branches` are configured correctly in the provider test. ([Pact Docs][8])
* **“How do I run everything in Docker?”** Use the `pactfoundation/pact-cli` image for broker CLI/verifier and the `pactfoundation/pact-broker` image for the Broker itself. ([Pact Docs][12])

---

### Appendix: Learning resources

* **Pact docs (core)** — intro, patterns, and all language guides. ([Pact Docs][1])
* **Pact JS** — consumer, provider, matching, XML, GraphQL, messages. ([Pact Docs][13])
* **JVM** — JUnit 5 consumer and provider extensions. ([Pact Docs][7])
* **Python** — overview + async message support. ([Pact Docs][20])
* **Broker** — can‑i‑deploy + deployments/releases workflow. ([Pact Docs][3])
* **Plugins** — Protobuf/gRPC examples and plugin framework. ([Pact Docs][5])

---

### TL;DR

1. Write **consumer tests** → generate pact files.
2. **Publish** pacts to a **Broker**.
3. Run **provider verifications** (with provider states + selectors + pending/WIP).
4. Use **can‑i‑deploy** to block unsafe releases.
5. For non‑JSON/non‑HTTP, use Pact’s **plugins** (e.g., Protobuf/gRPC).

This workflow gives you fast feedback, safer deploys, and contracts that evolve at the same pace as your code. ([Pact Docs][1])

If you want this trimmed to a one‑pager checklist or transformed into a “company‑style” README template with scripts for your stack, say which language(s) and CI you use and I’ll tailor it.

[1]: https://docs.pact.io/?utm_source=chatgpt.com "Pact Docs: Introduction"
[2]: https://docs.pact.io/getting_started/provider_states?utm_source=chatgpt.com "Provider states"
[3]: https://docs.pact.io/pact_broker/can_i_deploy "Can I Deploy | Pact Docs"
[4]: https://docs.pact.io/implementation_guides/javascript/docs/matching "Matching | Pact Docs"
[5]: https://docs.pact.io/plugins/quick_start?utm_source=chatgpt.com "Pact Plugins"
[6]: https://docs.pact.io/implementation_guides/javascript/readme "Overview | Pact Docs"
[7]: https://docs.pact.io/implementation_guides/jvm/consumer/junit5 "pact-jvm-consumer-junit5 | Pact Docs"
[8]: https://docs.pact.io/implementation_guides/jvm/provider/junit5 "Pact Junit 5 Extension | Pact Docs"
[9]: https://pypi.org/project/pact-python/2.1.2/?utm_source=chatgpt.com "pact-python"
[10]: https://www.nuget.org/packages/PactNet/?utm_source=chatgpt.com "PactNet 5.0.1"
[11]: https://docs.pact.io/pact_broker/docker_images/pactfoundation?utm_source=chatgpt.com "pactfoundation/pact-broker"
[12]: https://docs.pact.io/implementation_guides/cli "Pact command line tools | Pact Docs"
[13]: https://docs.pact.io/implementation_guides/javascript/docs/consumer "Consumer Tests | Pact Docs"
[14]: https://docs.pact.io/implementation_guides/javascript/docs/provider "Provider Verification | Pact Docs"
[15]: https://docs.pact.io/implementation_guides/javascript/docs/xml "XML | Pact Docs"
[16]: https://pact-foundation.github.io/pact-python/blog/2024/07/26/asynchronous-message-support/ "Asynchronous Message Support - Pact Python"
[17]: https://github.com/pactflow/pact-protobuf-plugin?utm_source=chatgpt.com "Pact plugin for Protobufs and gRPC"
[18]: https://docs.pact.io/university/introduction/Step12?utm_source=chatgpt.com "Step 12 - Using Webhooks"
[19]: https://docs.pactflow.io/?utm_source=chatgpt.com "PactFlow Documentation: Getting Started with PactFlow"
[20]: https://docs.pact.io/implementation_guides/python?utm_source=chatgpt.com "Overview | Pact Docs"
