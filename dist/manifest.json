{
  "version": 2,
  "generatedAt": "2025-11-25T05:49:33.060Z",
  "scripts": {
    "breakpoint.clear.file": {
      "metadata": {
        "alias": "breakpoint.clear.file",
        "name": "Clear File Breakpoints",
        "category": "breakpoint",
        "description": "Clear all breakpoints in a specific file",
        "dangerOnly": false,
        "params": {
          "path": {
            "type": "string",
            "required": true,
            "description": "File path (absolute or relative to current directory)",
            "resolve": "cwd-relative"
          }
        },
        "response": "action",
        "result": {
          "cleared": {
            "type": "number",
            "description": "Number of breakpoints cleared"
          },
          "path": {
            "type": "string",
            "description": "File path where breakpoints were cleared"
          }
        },
        "errors": [
          "E_FILE_NOT_FOUND",
          "E_INVALID_PATH"
        ],
        "cli": {
          "command": "bp clear-file",
          "description": "Clear breakpoints in a file",
          "examples": [
            "vscb script run breakpoint.clear.file --param path=test.js"
          ]
        },
        "mcp": {
          "enabled": true,
          "description": "Clear all breakpoints in a specific file (contrast: clear-project clears workspace-wide)",
          "timeout": 5000,
          "relationships": {
            "requires": [],
            "recommended": [],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_FILE_NOT_FOUND",
                "summary": "File path not found or not accessible",
                "is_retryable": true,
                "user_fix_hint": "Check file path and ensure it exists in workspace"
              },
              {
                "code": "E_INVALID_PATH",
                "summary": "File path is malformed or not a valid file",
                "is_retryable": true,
                "user_fix_hint": "Provide absolute or workspace-relative file path"
              }
            ]
          },
          "safety": {
            "idempotent": true,
            "read_only": false,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Removing all breakpoints from a single file when refactoring or debugging\n- Cleaning up file-specific breakpoints before setting new ones\n- Quick reset of debugging state for one file\n\nDON'T USE FOR:\n- Clearing all workspace breakpoints (use breakpoint.clear-project instead)\n- Removing a single specific breakpoint (use breakpoint.remove instead)\n\nPREREQUISITES:\n- File must exist in workspace (path must be valid)\n- No active debug session required (can clear at any time)\n\nSAFETY:\n- Idempotent (clearing twice achieves same result)\n- Not destructive (breakpoints can be re-added easily)\n",
            "parameter_hints": {
              "path": {
                "description": "Absolute or workspace-relative file path to clear breakpoints from",
                "required": true,
                "examples": [
                  "src/main.js",
                  "/absolute/path/to/file.py",
                  "lib/utils/helper.ts"
                ],
                "note": "Prefer workspace-relative paths for portability"
              }
            }
          }
        }
      },
      "scriptRelPath": "breakpoint/clear-file.js"
    },
    "breakpoint.clear.project": {
      "metadata": {
        "alias": "breakpoint.clear.project",
        "name": "Clear Project Breakpoints",
        "category": "breakpoint",
        "description": "Clear all breakpoints across the entire project",
        "dangerOnly": false,
        "params": {},
        "response": "action",
        "result": {
          "cleared": {
            "type": "number",
            "description": "Number of breakpoints cleared"
          }
        },
        "errors": [],
        "cli": {
          "command": "bp clear-project",
          "description": "Clear all breakpoints in the project",
          "examples": [
            "vscb script run breakpoint.clear.project"
          ]
        },
        "mcp": {
          "enabled": true,
          "description": "Clear all breakpoints across entire workspace (contrast: clear-file targets single file)",
          "timeout": 5000,
          "relationships": {
            "requires": [],
            "recommended": [],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": []
          },
          "safety": {
            "idempotent": true,
            "read_only": false,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Complete reset of debugging state across workspace\n- Starting fresh debugging session without old breakpoints\n- Cleanup before setting new systematic breakpoints\n\nDON'T USE FOR:\n- Clearing breakpoints in a single file (use breakpoint.clear-file instead)\n- Removing a specific breakpoint (use breakpoint.remove instead)\n\nPREREQUISITES:\n- None (always safe to execute)\n\nSAFETY:\n- Idempotent (clearing twice achieves same result)\n- Not destructive (breakpoints can be re-added easily)\n"
          }
        }
      },
      "scriptRelPath": "breakpoint/clear-project.js"
    },
    "breakpoint.list": {
      "metadata": {
        "alias": "breakpoint.list",
        "name": "List Breakpoints",
        "category": "breakpoint",
        "description": "List all active breakpoints in the workspace",
        "dangerOnly": false,
        "params": {},
        "response": "query",
        "errors": [],
        "cli": {
          "command": "bp list",
          "description": "List all breakpoints",
          "examples": [
            "vscb script run breakpoint.list"
          ]
        },
        "mcp": {
          "enabled": true,
          "description": "Query all active breakpoints in workspace with locations and conditions (read-only)",
          "timeout": 5000,
          "relationships": {
            "requires": [],
            "recommended": [],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": []
          },
          "safety": {
            "idempotent": true,
            "read_only": true,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Inspecting current breakpoint configuration before debugging\n- Finding breakpoint locations to remove or modify\n- Verifying breakpoints were set correctly\n\nDON'T USE FOR:\n- Setting breakpoints (use breakpoint.set instead)\n- Removing breakpoints (use breakpoint.remove/clear-file/clear-project)\n\nPREREQUISITES:\n- None (always safe to query)\n\nSAFETY:\n- Read-only operation (no state changes)\n- Idempotent (querying multiple times returns same results)\n"
          }
        }
      },
      "scriptRelPath": "breakpoint/list.js"
    },
    "breakpoint.remove": {
      "metadata": {
        "alias": "breakpoint.remove",
        "name": "Remove Breakpoint",
        "category": "breakpoint",
        "description": "Remove a breakpoint at a specific line",
        "dangerOnly": false,
        "params": {
          "path": {
            "type": "string",
            "required": true,
            "description": "File path (absolute or relative to current directory)",
            "resolve": "cwd-relative"
          },
          "line": {
            "type": "number",
            "required": true,
            "description": "Line number (1-indexed)"
          }
        },
        "response": "action",
        "errors": [
          "E_NOT_FOUND",
          "E_INVALID_PARAMS"
        ],
        "cli": {
          "command": "bp remove",
          "description": "Remove a specific breakpoint",
          "examples": [
            "vscb script run breakpoint.remove --param path=test.js --param line=42"
          ]
        },
        "mcp": {
          "enabled": false,
          "description": "Remove a specific breakpoint by file path and line number (contrast: clear-file/clear-project remove multiple)",
          "timeout": 5000,
          "relationships": {
            "requires": [],
            "recommended": [],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_NOT_FOUND",
                "summary": "No breakpoint exists at specified file and line",
                "is_retryable": false,
                "user_fix_hint": "Use breakpoint.list to find actual breakpoint locations"
              },
              {
                "code": "E_INVALID_PARAMS",
                "summary": "Invalid file path or line number",
                "is_retryable": true,
                "user_fix_hint": "Verify path exists and line is a positive integer"
              }
            ]
          },
          "safety": {
            "idempotent": true,
            "read_only": false,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Removing a single specific breakpoint by location\n- Selective cleanup of breakpoints during debugging\n- Disabling one breakpoint while keeping others\n\nDON'T USE FOR:\n- Clearing all breakpoints in a file (use breakpoint.clear-file instead)\n- Clearing all workspace breakpoints (use breakpoint.clear-project instead)\n\nPREREQUISITES:\n- Breakpoint must exist at specified file and line\n- File must exist in workspace\n\nSAFETY:\n- Idempotent (removing same breakpoint twice is safe)\n- Not destructive (breakpoint can be re-added easily)\n",
            "parameter_hints": {
              "path": {
                "description": "Absolute or workspace-relative file path containing breakpoint",
                "required": true,
                "examples": [
                  "src/main.js",
                  "/absolute/path/to/file.py",
                  "test/integration/api.test.ts"
                ],
                "note": "Must match path used when breakpoint was created"
              },
              "line": {
                "description": "1-indexed line number where breakpoint exists",
                "required": true,
                "examples": [
                  "10",
                  "42",
                  "150"
                ],
                "note": "Must match exact line where breakpoint was set"
              }
            }
          }
        }
      },
      "scriptRelPath": "breakpoint/remove.js"
    },
    "breakpoint.set": {
      "metadata": {
        "alias": "breakpoint.set",
        "name": "Set Breakpoint",
        "category": "breakpoint",
        "description": "Set a breakpoint with optional conditions and log messages",
        "dangerOnly": false,
        "params": {
          "path": {
            "type": "string",
            "required": true,
            "description": "File path (absolute or relative to current directory)",
            "resolve": "cwd-relative"
          },
          "line": {
            "type": "number",
            "required": true,
            "description": "Line number (1-indexed)",
            "min": 1
          },
          "condition": {
            "type": "string",
            "required": false,
            "description": "Conditional expression for breakpoint"
          },
          "hitCondition": {
            "type": "string",
            "required": false,
            "description": "Hit count expression (e.g., \">5\", \"==10\")"
          },
          "logMessage": {
            "type": "string",
            "required": false,
            "description": "Message to log when breakpoint hits (logpoint)"
          }
        },
        "response": "action",
        "result": {
          "breakpoint": {
            "type": "object",
            "description": "Created breakpoint details"
          }
        },
        "errors": [
          "E_FILE_NOT_FOUND",
          "E_INVALID_LINE",
          "E_INVALID_PATH"
        ],
        "cli": {
          "command": "bp set",
          "description": "Set a breakpoint",
          "examples": [
            "vscb script run breakpoint.set --param path=test.js --param line=42",
            "vscb script run breakpoint.set --param path=./test.js --param line=42 --param condition=\"x > 10\"",
            "vscb script run breakpoint.set --param path=src/main.py --param line=42 --param hitCondition=\">5\"",
            "vscb script run breakpoint.set --param path=test.js --param line=42 --param logMessage=\"Value is {x}\""
          ]
        },
        "mcp": {
          "enabled": true,
          "description": "Set a line or conditional breakpoint in active or future debug session",
          "timeout": 5000,
          "relationships": {
            "requires": [],
            "recommended": [],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_FILE_NOT_FOUND",
                "summary": "File path not found or not accessible",
                "is_retryable": true,
                "user_fix_hint": "Check file path and ensure it exists in workspace"
              },
              {
                "code": "E_INVALID_LINE",
                "summary": "Line number not executable or out of range",
                "is_retryable": true,
                "user_fix_hint": "Verify line number exists and contains executable code"
              }
            ]
          },
          "safety": {
            "idempotent": true,
            "read_only": false,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Pausing execution at a specific line in any debug session\n- Setting conditional breakpoints (pause only when expression true)\n- Creating logpoints (log without pausing via logMessage parameter)\n\nDON'T USE FOR:\n- Watch expressions (use debug.watch_add if available)\n- Temporary inspection (use debug.evaluate after pausing)\n\nPREREQUISITES:\n- File must exist in workspace (can set before debug session starts)\n- Line must contain executable code (not comments or blank lines)\n- For conditionals: expression must be valid in target language\n\nSAFETY:\n- Idempotent (setting same breakpoint twice is safe)\n- Read-only to program state (modifies debugger state only)\n",
            "parameter_hints": {
              "path": {
                "description": "Absolute or workspace-relative file path",
                "required": true,
                "examples": [
                  "src/main.js",
                  "/absolute/path/to/file.py"
                ],
                "note": "Prefer workspace-relative paths for portability"
              },
              "line": {
                "description": "1-indexed line number where breakpoint should be set",
                "required": true,
                "examples": [
                  "10",
                  "42",
                  "100"
                ],
                "note": "First line is 1, not 0"
              },
              "condition": {
                "description": "Language-specific boolean expression evaluated at breakpoint",
                "required": false,
                "examples": [
                  "x > 10",
                  "user === null",
                  "len(items) > 0"
                ],
                "language_specific": {
                  "python": "Use Python syntax (e.g., 'len(items) > 0')",
                  "javascript": "Use JavaScript syntax (e.g., 'items.length > 0')",
                  "csharp": "Use C# syntax (e.g., 'items.Count > 0')"
                },
                "pitfalls": [
                  "Don't mix Python syntax in JS sessions or vice-versa",
                  "Keep expressions side-effect free (no assignments)"
                ]
              },
              "hitCondition": {
                "description": "Hit count expression controlling when breakpoint triggers",
                "required": false,
                "examples": [
                  ">5",
                  "==10"
                ],
                "note": "Breakpoint triggers when hit count matches expression"
              },
              "logMessage": {
                "description": "Message to log when breakpoint hits (logpoint mode, doesn't pause)",
                "required": false,
                "examples": [
                  "Value is {x}",
                  "User: {user.name}, Age: {user.age}"
                ],
                "note": "Use {expression} syntax to interpolate variables"
              }
            }
          }
        }
      },
      "scriptRelPath": "breakpoint/set.js"
    },
    "code.replace-method": {
      "metadata": {
        "alias": "code.replace-method",
        "name": "Method Replacement",
        "category": "code",
        "description": "Replace entire method declarations using whole-symbol replacement (signature + body). Supports async conversion, parameter changes, and deletion via empty string.",
        "dangerOnly": false,
        "params": {
          "nodeId": {
            "type": "string",
            "required": false,
            "description": "Flowspace ID (e.g., \"method:src/Calculator.ts:Calculator.add\")"
          },
          "path": {
            "type": "string",
            "required": false,
            "description": "File path (required with symbol parameter, alternative to nodeId)",
            "resolve": "cwd-relative"
          },
          "symbol": {
            "type": "string",
            "required": false,
            "description": "Symbol name (e.g., \"Calculator.add\", required with path parameter)"
          },
          "replacement": {
            "type": "string",
            "required": true,
            "description": "Replacement text (entire method declaration; empty string deletes method)"
          }
        },
        "response": "action",
        "result": {
          "success": {
            "type": "boolean",
            "description": "True if replacement applied successfully"
          },
          "details": {
            "type": "object",
            "description": "Replacement operation details",
            "properties": {
              "applied": {
                "type": "boolean",
                "description": "True if WorkspaceEdit was applied"
              },
              "changes": {
                "type": "array",
                "description": "Details of method replacement (range, old/new text)"
              },
              "succeeded": {
                "type": "array",
                "description": "Files saved successfully"
              },
              "failed": {
                "type": "array",
                "description": "Files that failed to save (best-effort)"
              },
              "totalFiles": {
                "type": "number",
                "description": "Total number of files modified (always 1)"
              },
              "totalEdits": {
                "type": "number",
                "description": "Total number of text edits applied (always 1)"
              },
              "input": {
                "type": "object",
                "description": "Input parameters used"
              }
            }
          }
        },
        "errors": [
          "E_NOT_FOUND",
          "E_AMBIGUOUS_SYMBOL",
          "E_INVALID_INPUT",
          "E_NO_LANGUAGE_SERVER",
          "E_FILE_READ_ONLY",
          "E_OPERATION_FAILED",
          "E_TIMEOUT"
        ],
        "cli": {
          "command": "code replace-method",
          "description": "Replace entire method declaration using whole-symbol replacement",
          "examples": [
            "vscb script run code.replace-method --param nodeId=\"method:test/python/test_example.py:add_numbers\" --param replacement=\"def add_numbers(a, b): return a + b\"",
            "vscb script run code.replace-method --param path=\"src/Calculator.ts\" --param symbol=\"Calculator.add\" --param replacement=\"add(a: number, b: number): number { return a + b; }\"",
            "vscb script run code.replace-method --param nodeId=\"method:src/User.py:User.validate\" --param replacement=\"\""
          ]
        },
        "mcp": {
          "enabled": true,
          "description": "Replace entire method declarations using whole-symbol replacement (signature + body). Supports async conversion, parameter changes, and deletion via empty string.",
          "timeout": 15000,
          "relationships": {
            "requires": [],
            "recommended": [
              {
                "tool": "search.symbol-search",
                "note": "Find methods before replacing"
              },
              {
                "tool": "symbol.navigate",
                "note": "Preview references before making changes"
              },
              {
                "tool": "symbol.rename",
                "note": "⚠️ Different operation: rename updates all references, replace only changes declaration"
              }
            ],
            "provides": [],
            "conflicts": [
              {
                "tool": "symbol.rename",
                "note": "Use rename for identifier changes (updates references), use replace-method for signature/body changes (no reference updates)"
              }
            ]
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_NOT_FOUND",
                "summary": "Symbol not found at specified location",
                "is_retryable": false,
                "user_fix_hint": "Verify symbol name/Flowspace ID is correct and symbol exists in file. Use search.symbol-search to find available symbols."
              },
              {
                "code": "E_AMBIGUOUS_SYMBOL",
                "summary": "Multiple symbols match the given name",
                "is_retryable": true,
                "user_fix_hint": "Use more specific qualified name (e.g., 'ClassName.methodName' instead of 'methodName') or use Flowspace ID for exact positioning."
              },
              {
                "code": "E_INVALID_INPUT",
                "summary": "Invalid parameters: must provide either nodeId OR both path and symbol, replacement is required",
                "is_retryable": true,
                "user_fix_hint": "Check parameter combination - use nodeId alone OR path+symbol together, ensure replacement is provided (empty string is valid for deletion)"
              },
              {
                "code": "E_NO_LANGUAGE_SERVER",
                "summary": "No document symbol provider available for this file type",
                "is_retryable": false,
                "user_fix_hint": "Install appropriate language extension (Python: Pylance, JavaScript/TypeScript: built-in, Java: Java Language Support, etc.)"
              },
              {
                "code": "E_FILE_READ_ONLY",
                "summary": "File is read-only or permission denied",
                "is_retryable": false,
                "user_fix_hint": "Check file permissions using chmod/attrib; ensure file is not locked by another application"
              },
              {
                "code": "E_OPERATION_FAILED",
                "summary": "WorkspaceEdit application failed",
                "is_retryable": true,
                "user_fix_hint": "Common causes: (1) File locked by another application, (2) File modified concurrently, (3) File deleted after validation. Ensure file is saved and not open in other editors. Try again after closing other editors."
              },
              {
                "code": "E_TIMEOUT",
                "summary": "LSP document symbol provider timeout (10s)",
                "is_retryable": true,
                "user_fix_hint": "Try again; if persists, check language server is responding (large files may be slow to index)"
              }
            ]
          },
          "safety": {
            "idempotent": false,
            "read_only": false,
            "destructive": true
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Replacing entire method declarations (signature + body)\n- Converting methods to async/await patterns\n- Adding/removing/reordering parameters with body changes\n- Changing return types with implementation updates\n- Deleting methods entirely (empty string replacement)\n- Refactoring method implementations while keeping same name\n- Adding error handling, logging, or validation to methods\n\nDON'T USE FOR:\n- Renaming methods (use symbol.rename - updates all references)\n- Partial edits within method body (use text editor or Edit tool)\n- Refactoring across multiple methods (call once per method)\n- Preview/dry-run (no preview mode - operation is destructive)\n- Formatting only (use language formatter)\n\nPREREQUISITES:\n- File must exist and be indexed by VS Code\n- Symbol must exist at specified location (function, method, or class method)\n- Language server must provide document symbols (TypeScript, Python, Java, JavaScript, C#, Go, Rust)\n- File must be writable (not read-only)\n- File should be saved before replacement\n\nSAFETY:\n- ⚠️ DESTRUCTIVE OPERATION: Modifies file immediately (cannot undo via API)\n- NOT atomic with document save: WorkspaceEdit applies atomically, but save is best-effort\n- Check result.details.failed array for save failures\n- NOT idempotent (running twice replaces with same text twice)\n- Commit changes to version control before replacement for easy rollback\n- Empty string replacement deletes entire method (may leave blank lines)\n\nWORKFLOW:\n1. (Recommended) Commit current changes to git for easy rollback\n2. (Optional) Call symbol.navigate to preview references (replacement doesn't update them)\n3. Call code.replace-method with new method text\n4. Check result.details.succeeded/failed to verify save status\n5. Test the changes before committing\n\nPERFORMANCE NOTES:\n- First workspace call: 3-10s (cold start indexing)\n- Subsequent calls: <1s for method replacement\n- Pre-validation adds ~10-50ms (file permission checks)\n- Timeout protection: 15s max\n\nRESPONSE FORMAT:\n- This tool returns ActionScript envelope: {success: true, details: {...}} or {success: false, reason: \"...\"}\n- Access results via: result.details.changes (NOT result.changes directly)\n- Check operation success: result.success === true before accessing result.details\n- Check save status: result.details.failed array may contain files that failed to save\n\nCOMPARISON WITH symbol.rename:\n- symbol.rename: Changes identifier name, updates ALL references workspace-wide\n- code.replace-method: Replaces entire declaration, does NOT update references\n- Use rename for identifier changes (foo → bar)\n- Use replace-method for signature/body changes (async conversion, parameter changes)\n\nEMPTY STRING REPLACEMENT (DELETION):\n- replacement=\"\" deletes entire method\n- May leave blank lines (no smart whitespace handling)\n- Simple, predictable behavior\n- Caller must format indentation correctly\n",
            "parameter_hints": {
              "nodeId": {
                "description": "Flowspace ID for semantic, position-independent method identification",
                "required": false,
                "examples": [
                  "method:src/Calculator.ts:Calculator.add",
                  "function:src/utils.js:formatDate",
                  "method:test/python/test_example.py:TestMathCalculator.test_addition"
                ],
                "note": "Preferred for automation - no cursor position needed, works across file moves",
                "pitfalls": [
                  "Use forward slashes in Windows paths (C:/Users/ not C:\\Users\\)",
                  "Qualified names must match exact symbol hierarchy",
                  "Only works for functions/methods, not variables or classes"
                ]
              },
              "path": {
                "description": "File path for symbol name lookup (alternative to nodeId)",
                "required": false,
                "examples": [
                  "src/Calculator.ts",
                  "test/python/test_example.py",
                  "/absolute/path/to/file.js"
                ],
                "note": "Required when using symbol parameter, ignored when nodeId provided"
              },
              "symbol": {
                "description": "Symbol qualified name within file (alternative to nodeId)",
                "required": false,
                "examples": [
                  "Calculator.add",
                  "TestMathCalculator.test_addition",
                  "formatDate"
                ],
                "note": "Required when using path parameter, supports hierarchical names (Class.method)",
                "pitfalls": [
                  "Must be qualified for nested symbols (use 'Outer.Inner.method' not just 'method')",
                  "Case-sensitive matching"
                ]
              },
              "replacement": {
                "description": "Complete method declaration text (signature + body)",
                "required": true,
                "examples": [
                  "def add_numbers(a: int, b: int) -> int:\n    return a + b",
                  "async def fetch_data(url: str) -> dict:\n    response = await aiohttp.get(url)\n    return await response.json()",
                  ""
                ],
                "note": "Must include correct indentation for the target language; empty string deletes method",
                "language_specific": {
                  "python": "Use consistent indentation (4 spaces standard), include type hints if original had them",
                  "typescript": "Match surrounding code style (tabs vs spaces), include access modifiers (public/private)",
                  "javascript": "Match surrounding code style, consider CommonJS vs ES6 syntax",
                  "java": "Include access modifiers (public/private/protected), match bracing style"
                },
                "pitfalls": [
                  "Caller must format indentation correctly (no auto-formatting)",
                  "Empty string leaves blank lines (no smart whitespace handling)",
                  "Does NOT update callers if signature changes (manual fixes required)",
                  "Must preserve language-specific syntax (async/await, return types, etc.)"
                ]
              }
            }
          }
        }
      },
      "scriptRelPath": "code/replace-method.js"
    },
    "dap.compare": {
      "metadata": {
        "alias": "dap.compare",
        "category": "dap",
        "description": "Compare two debug sessions to find differences and regressions",
        "dangerOnly": false,
        "params": {
          "sessionA": {
            "type": "string",
            "required": true,
            "description": "First debug session ID"
          },
          "sessionB": {
            "type": "string",
            "required": true,
            "description": "Second debug session ID to compare against"
          },
          "compareBy": {
            "type": "enum",
            "values": [
              "counts",
              "exceptions",
              "timeline",
              "outputs"
            ],
            "required": false,
            "default": "counts",
            "description": "What aspect to compare (counts=numeric deltas, exceptions=diff, timeline=divergence point, outputs=detailed breakdown)"
          }
        },
        "response": "query",
        "errors": [
          "E_SESSION_NOT_FOUND",
          "E_INSUFFICIENT_DATA"
        ],
        "cli": {
          "command": "dap compare",
          "description": "Compare two debug sessions",
          "examples": [
            "vscb script run dap.compare --param sessionA=abc-123 --param sessionB=def-456",
            "vscb script run dap.compare --param sessionA=abc --param sessionB=def --param compareBy=exceptions"
          ]
        },
        "mcp": {
          "enabled": false,
          "description": "Side-by-side comparison of two debug sessions for regression testing and divergence analysis",
          "timeout": 30000,
          "relationships": {
            "requires": [],
            "recommended": [],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_SESSION_NOT_FOUND",
                "summary": "One or both session IDs do not exist",
                "is_retryable": false,
                "user_fix_hint": "Verify both sessionA and sessionB are valid session IDs"
              },
              {
                "code": "E_INSUFFICIENT_DATA",
                "summary": "One or both sessions have insufficient data for comparison",
                "is_retryable": false,
                "user_fix_hint": "Ensure both sessions have completed and captured events"
              }
            ]
          },
          "safety": {
            "idempotent": true,
            "read_only": true,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Comparing two debug sessions to find differences\n- Regression testing (before/after code changes)\n- Identifying divergence points in execution paths\n- Analyzing output count changes or exception differences\n\nDON'T USE FOR:\n- Viewing single session data (use dap.logs or dap.summary)\n- Searching across sessions (use dap.search with sessionId=all)\n- Statistical analysis (use dap.stats)\n- Exception analysis in single session (use dap.exceptions)\n\nPREREQUISITES:\n- Both sessionA and sessionB must be valid session IDs\n- Both sessions should have completed and captured data\n\nSAFETY:\n- Read-only operation (no state changes)\n- Idempotent (same comparison returns same results)\n",
            "parameter_hints": {
              "sessionA": {
                "description": "First debug session ID to compare",
                "required": true,
                "examples": [
                  "abc-123-def",
                  "baseline-session",
                  "session-before-fix"
                ],
                "note": "Must be a valid session ID"
              },
              "sessionB": {
                "description": "Second debug session ID to compare against",
                "required": true,
                "examples": [
                  "xyz-789-ghi",
                  "current-session",
                  "session-after-fix"
                ],
                "note": "Must be a valid session ID"
              },
              "compareBy": {
                "description": "Aspect of sessions to compare",
                "required": false,
                "examples": [
                  "counts",
                  "exceptions",
                  "timeline"
                ],
                "note": "counts=numeric deltas, exceptions=diff, timeline=divergence point, outputs=detailed breakdown"
              }
            }
          }
        }
      },
      "scriptRelPath": "dap/compare.js"
    },
    "dap.exceptions": {
      "metadata": {
        "alias": "dap.exceptions",
        "category": "dap",
        "description": "Show exceptions with surrounding context and stack traces",
        "dangerOnly": false,
        "params": {
          "sessionId": {
            "type": "string",
            "required": false,
            "description": "Debug session ID (defaults to latest session)"
          },
          "count": {
            "type": "number",
            "required": false,
            "default": 10,
            "description": "How many exceptions to show (1-100)"
          },
          "withContext": {
            "type": "boolean",
            "required": false,
            "default": true,
            "description": "Include surrounding outputs before/after exception"
          },
          "contextLines": {
            "type": "number",
            "required": false,
            "default": 5,
            "description": "How many output lines before/after to show (0-50)"
          }
        },
        "response": "query",
        "errors": [
          "E_NO_EXCEPTIONS",
          "E_NO_SESSION"
        ],
        "cli": {
          "command": "dap exceptions",
          "description": "Deep dive into exceptions with context",
          "examples": [
            "vscb script run dap.exceptions",
            "vscb script run dap.exceptions --param count=5",
            "vscb script run dap.exceptions --param withContext=false",
            "vscb script run dap.exceptions --param contextLines=10"
          ]
        },
        "mcp": {
          "enabled": false,
          "description": "Inspect exceptions with surrounding context and stack traces for deep error analysis",
          "timeout": 30000,
          "relationships": {
            "requires": [],
            "recommended": [],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_NO_EXCEPTIONS",
                "summary": "No exceptions found in specified session",
                "is_retryable": false,
                "user_fix_hint": "Session may have run successfully without errors, or sessionId is incorrect"
              },
              {
                "code": "E_NO_SESSION",
                "summary": "No debug session found",
                "is_retryable": false,
                "user_fix_hint": "Start a debug session first or specify a valid sessionId"
              }
            ]
          },
          "safety": {
            "idempotent": true,
            "read_only": true,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Deep dive into exception details and stack traces\n- Understanding exception context (surrounding outputs)\n- Analyzing error patterns in debug sessions\n- Getting exception-focused view of session failures\n\nDON'T USE FOR:\n- General log viewing (use dap.logs)\n- Searching for non-exception patterns (use dap.search)\n- Comparing exception counts between sessions (use dap.compare)\n- Statistical analysis of all outputs (use dap.stats)\n\nPREREQUISITES:\n- Debug session must have captured exception events\n- For specific session, sessionId must be valid\n\nSAFETY:\n- Read-only operation (no state changes)\n- Idempotent (same query returns same results)\n",
            "parameter_hints": {
              "sessionId": {
                "description": "Debug session to retrieve exceptions from",
                "required": false,
                "examples": [
                  "latest",
                  "abc-123-def",
                  "null (defaults to latest)"
                ],
                "note": "Defaults to most recent session if omitted"
              },
              "count": {
                "description": "Maximum number of exceptions to return",
                "required": false,
                "examples": [
                  "10",
                  "5",
                  "20"
                ],
                "note": "Default is 10, range is 1-100"
              },
              "withContext": {
                "description": "Include surrounding output lines before/after exception",
                "required": false,
                "examples": [
                  "true",
                  "false"
                ],
                "note": "Default is true (includes context)"
              },
              "contextLines": {
                "description": "Number of output lines to show before/after exception",
                "required": false,
                "examples": [
                  "5",
                  "10",
                  "20"
                ],
                "note": "Default is 5, range is 0-50",
                "pitfalls": [
                  "High values may produce large output if many exceptions exist"
                ]
              }
            }
          }
        }
      },
      "scriptRelPath": "dap/exceptions.js"
    },
    "dap.filter": {
      "metadata": {
        "alias": "dap.filter",
        "category": "dap",
        "description": "Complex filtering with multiple AND-ed criteria",
        "dangerOnly": false,
        "params": {
          "sessionId": {
            "type": "string",
            "required": false,
            "description": "Debug session ID (defaults to latest session)"
          },
          "filters": {
            "type": "object",
            "required": true,
            "description": "Filter criteria object with categories, timeRange, exclude, include, sources, minLength, maxLength"
          }
        },
        "response": "query",
        "errors": [
          "E_INVALID_FILTERS",
          "E_NO_RESULTS"
        ],
        "cli": {
          "command": "dap filter",
          "description": "Advanced multi-criteria filtering",
          "examples": [
            "vscb script run dap.filter --param 'filters={\"categories\":[\"stdout\"],\"sources\":[\"test.js\"]}'",
            "vscb script run dap.filter --param 'filters={\"categories\":[\"stderr\"],\"timeRange\":{\"start\":1234567890,\"end\":1234567999}}'",
            "vscb script run dap.filter --param 'filters={\"include\":[\"ERROR\"],\"exclude\":[\"DEBUG\"]}'"
          ]
        },
        "mcp": {
          "enabled": false,
          "description": "Complex filtering of debug outputs with multiple AND-ed criteria for precise log queries",
          "timeout": 30000,
          "relationships": {
            "requires": [],
            "recommended": [],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_INVALID_FILTERS",
                "summary": "Filter object has invalid structure or values",
                "is_retryable": true,
                "user_fix_hint": "Check filters object has valid properties: categories, timeRange, exclude, include, sources, minLength, maxLength"
              },
              {
                "code": "E_NO_RESULTS",
                "summary": "No outputs match the specified filter criteria",
                "is_retryable": false,
                "user_fix_hint": "Try relaxing filter criteria or verify sessionId is correct"
              }
            ]
          },
          "safety": {
            "idempotent": true,
            "read_only": true,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Complex multi-criteria filtering (category AND time AND source)\n- Precise log queries with multiple constraints\n- Filtering by source file or output length\n- Advanced include/exclude pattern combinations\n\nDON'T USE FOR:\n- Simple category filtering (use dap.logs with category parameter)\n- Single pattern search (use dap.search)\n- Exception-focused queries (use dap.exceptions)\n- Statistical analysis (use dap.stats)\n\nPREREQUISITES:\n- DAP logger must have captured session data\n- For specific session, sessionId must be valid\n\nSAFETY:\n- Read-only operation (no state changes)\n- Idempotent (same filters return same results)\n",
            "parameter_hints": {
              "sessionId": {
                "description": "Debug session to filter outputs from",
                "required": false,
                "examples": [
                  "latest",
                  "abc-123-def",
                  "null (defaults to latest)"
                ],
                "note": "Defaults to most recent session if omitted"
              },
              "filters": {
                "description": "Filter criteria object with AND-ed conditions",
                "required": true,
                "examples": [
                  "{\"categories\":[\"stdout\"],\"sources\":[\"test.js\"]}",
                  "{\"include\":[\"ERROR\"],\"exclude\":[\"DEBUG\"]}",
                  "{\"timeRange\":{\"start\":1234567890,\"end\":1234567999}}"
                ],
                "note": "Multiple criteria are combined with AND logic",
                "pitfalls": [
                  "Use valid property names: categories, timeRange, exclude, include, sources, minLength, maxLength",
                  "All criteria must match for output to be included"
                ]
              }
            }
          }
        }
      },
      "scriptRelPath": "dap/filter.js"
    },
    "dap.logs": {
      "metadata": {
        "alias": "dap.logs",
        "category": "dap",
        "description": "View recent console output with filtering by category, search, and time",
        "dangerOnly": false,
        "params": {
          "sessionId": {
            "type": "string",
            "required": false,
            "description": "Debug session ID (defaults to latest session)"
          },
          "count": {
            "type": "number",
            "required": false,
            "default": 20,
            "description": "How many logs to show (1-10000)"
          },
          "category": {
            "type": "enum",
            "values": [
              "all",
              "stdout",
              "stderr",
              "console",
              "telemetry"
            ],
            "required": false,
            "default": "all",
            "description": "Filter by output category"
          },
          "search": {
            "type": "string",
            "required": false,
            "description": "Text or regex pattern to search for"
          },
          "since": {
            "type": "number",
            "required": false,
            "description": "Timestamp in ms or negative offset (e.g. -2000 for last 2 seconds)"
          },
          "reverse": {
            "type": "boolean",
            "required": false,
            "default": false,
            "description": "Show oldest first instead of most recent first"
          },
          "showSource": {
            "type": "boolean",
            "required": false,
            "default": true,
            "description": "Include file:line:column source information"
          }
        },
        "response": "query",
        "errors": [
          "E_NO_LOGS",
          "E_INVALID_PARAM"
        ],
        "cli": {
          "command": "dap logs",
          "description": "View recent console output with filtering",
          "examples": [
            "vscb script run dap.logs",
            "vscb script run dap.logs --param count=50 --param category=stdout",
            "vscb script run dap.logs --param search=ERROR",
            "vscb script run dap.logs --param since=-2000"
          ]
        },
        "mcp": {
          "enabled": false,
          "description": "View and filter recent debug session console output with flexible filtering options",
          "timeout": 30000,
          "relationships": {
            "requires": [],
            "recommended": [],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_NO_LOGS",
                "summary": "No logs found for specified session",
                "is_retryable": false,
                "user_fix_hint": "Start a debug session first or specify a valid sessionId"
              },
              {
                "code": "E_INVALID_PARAM",
                "summary": "Invalid parameter value (count, category, or time range)",
                "is_retryable": true,
                "user_fix_hint": "Check parameter constraints: count (1-10000), category (stdout|stderr|console|telemetry|all)"
              }
            ]
          },
          "safety": {
            "idempotent": true,
            "read_only": true,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Viewing recent console output from debug sessions\n- Filtering logs by category (stdout, stderr, console, telemetry)\n- Searching for specific text or regex patterns in outputs\n- Time-based log retrieval (last N seconds or since timestamp)\n\nDON'T USE FOR:\n- Searching across multiple sessions (use dap.search with sessionId=all)\n- Comparing logs between sessions (use dap.compare)\n- Analyzing exception details (use dap.exceptions)\n- Statistical analysis of output patterns (use dap.stats)\n\nPREREQUISITES:\n- DAP logger is always available (no session required)\n- For session-specific logs, sessionId must be valid\n\nSAFETY:\n- Read-only operation (no state changes)\n- Idempotent (same query returns same results)\n",
            "parameter_hints": {
              "sessionId": {
                "description": "Debug session ID to retrieve logs from",
                "required": false,
                "examples": [
                  "latest",
                  "abc-123-def",
                  "null (defaults to latest)"
                ],
                "note": "Defaults to most recent session if omitted"
              },
              "count": {
                "description": "Maximum number of log entries to return",
                "required": false,
                "examples": [
                  "20",
                  "50",
                  "100"
                ],
                "note": "Default is 20, range is 1-10000"
              },
              "category": {
                "description": "Filter logs by output category",
                "required": false,
                "examples": [
                  "stdout",
                  "stderr",
                  "console"
                ],
                "note": "Use 'all' to see all categories (default)"
              },
              "search": {
                "description": "Text or regex pattern to filter log entries",
                "required": false,
                "examples": [
                  "ERROR",
                  "user_id:\\s*\\d+",
                  "TestCase"
                ],
                "note": "Supports JavaScript regex syntax"
              },
              "since": {
                "description": "Timestamp or negative offset for time-based filtering",
                "required": false,
                "examples": [
                  "-2000 (last 2 seconds)",
                  "1609459200000 (Unix timestamp)",
                  "-5000 (last 5 seconds)"
                ],
                "pitfalls": [
                  "Negative values are relative to current time, not session start"
                ]
              },
              "reverse": {
                "description": "Show logs in chronological order (oldest first)",
                "required": false,
                "examples": [
                  "true",
                  "false"
                ],
                "note": "Default is false (most recent first)"
              },
              "showSource": {
                "description": "Include source file location (file:line:column) in output",
                "required": false,
                "examples": [
                  "true",
                  "false"
                ],
                "note": "Default is true"
              }
            }
          }
        }
      },
      "scriptRelPath": "dap/logs.js"
    },
    "dap.search": {
      "metadata": {
        "alias": "dap.search",
        "category": "dap",
        "description": "Search for text/regex patterns in session outputs with context",
        "dangerOnly": false,
        "params": {
          "sessionId": {
            "type": "string",
            "required": false,
            "description": "Debug session ID or 'all' to search all sessions (defaults to latest)"
          },
          "pattern": {
            "type": "string",
            "required": true,
            "description": "Text or regex pattern to search for"
          },
          "category": {
            "type": "enum",
            "values": [
              "all",
              "stdout",
              "stderr",
              "console",
              "telemetry"
            ],
            "required": false,
            "description": "Filter to specific category before searching"
          },
          "contextLines": {
            "type": "number",
            "required": false,
            "default": 2,
            "description": "How many lines before/after to show (0-20)"
          },
          "limit": {
            "type": "number",
            "required": false,
            "default": 50,
            "description": "Max results to return (1-1000)"
          },
          "caseSensitive": {
            "type": "boolean",
            "required": false,
            "default": false,
            "description": "Case-sensitive search"
          }
        },
        "response": "query",
        "errors": [
          "E_NO_RESULTS",
          "E_INVALID_REGEX"
        ],
        "cli": {
          "command": "dap search",
          "description": "Search for patterns in session outputs",
          "examples": [
            "vscb script run dap.search --param pattern=ERROR",
            "vscb script run dap.search --param pattern=\"user_id:\\s*\\d+\" --param sessionId=latest",
            "vscb script run dap.search --param pattern=TestCase --param caseSensitive=true"
          ]
        },
        "mcp": {
          "enabled": false,
          "description": "Search for text or regex patterns across debug session outputs with context lines",
          "timeout": 30000,
          "relationships": {
            "requires": [],
            "recommended": [],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_NO_RESULTS",
                "summary": "Pattern not found in session outputs",
                "is_retryable": false,
                "user_fix_hint": "Try broader search pattern or check sessionId is correct"
              },
              {
                "code": "E_INVALID_REGEX",
                "summary": "Invalid regular expression pattern",
                "is_retryable": true,
                "user_fix_hint": "Use valid JavaScript regex syntax (escape special chars like . * + ?)"
              }
            ]
          },
          "safety": {
            "idempotent": true,
            "read_only": true,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Finding specific error messages or patterns across logs\n- Searching with context lines before/after matches\n- Cross-session search (sessionId=all)\n- Regex pattern matching in debug outputs\n\nDON'T USE FOR:\n- Simple log viewing (use dap.logs instead)\n- Statistical analysis of patterns (use dap.stats)\n- Comparing outputs between sessions (use dap.compare)\n- Exception-focused analysis (use dap.exceptions)\n\nPREREQUISITES:\n- DAP logger must have captured session data\n- For specific session search, sessionId must be valid\n\nSAFETY:\n- Read-only operation (no state changes)\n- Idempotent (same search returns same results)\n",
            "parameter_hints": {
              "pattern": {
                "description": "Text or regex pattern to search for in outputs",
                "required": true,
                "examples": [
                  "ERROR",
                  "user_id:\\s*\\d+",
                  "TypeError.*undefined"
                ],
                "note": "Supports JavaScript regex syntax",
                "pitfalls": [
                  "Escape special regex characters: . * + ? [ ] ( ) { } ^ $ | \\"
                ]
              },
              "sessionId": {
                "description": "Session to search (or 'all' for cross-session search)",
                "required": false,
                "examples": [
                  "latest",
                  "abc-123-def",
                  "all"
                ],
                "note": "Defaults to latest session if omitted"
              },
              "category": {
                "description": "Filter to specific output category before searching",
                "required": false,
                "examples": [
                  "stderr",
                  "stdout",
                  "console"
                ],
                "note": "Use to narrow search scope for better performance"
              },
              "contextLines": {
                "description": "Number of lines to show before/after each match",
                "required": false,
                "examples": [
                  "2",
                  "5",
                  "10"
                ],
                "note": "Default is 2, range is 0-20"
              },
              "limit": {
                "description": "Maximum number of search results to return",
                "required": false,
                "examples": [
                  "50",
                  "100",
                  "500"
                ],
                "note": "Default is 50, range is 1-1000"
              },
              "caseSensitive": {
                "description": "Enable case-sensitive search",
                "required": false,
                "examples": [
                  "true",
                  "false"
                ],
                "note": "Default is false (case-insensitive)"
              }
            }
          }
        }
      },
      "scriptRelPath": "dap/search.js"
    },
    "dap.stats": {
      "metadata": {
        "alias": "dap.stats",
        "category": "dap",
        "description": "Analyze aggregate metrics and patterns across sessions",
        "dangerOnly": false,
        "params": {
          "sessionId": {
            "type": "string",
            "required": false,
            "description": "Debug session ID or 'all' for all sessions (defaults to latest)"
          },
          "groupBy": {
            "type": "enum",
            "values": [
              "category",
              "source",
              "hour",
              "session"
            ],
            "required": false,
            "default": "category",
            "description": "How to group statistics"
          },
          "includeCharts": {
            "type": "boolean",
            "required": false,
            "default": true,
            "description": "Generate ASCII charts for visualization"
          }
        },
        "response": "query",
        "errors": [
          "E_NO_DATA",
          "E_INVALID_GROUP_BY"
        ],
        "cli": {
          "command": "dap stats",
          "description": "Statistical analysis with charts",
          "examples": [
            "vscb script run dap.stats",
            "vscb script run dap.stats --param sessionId=all",
            "vscb script run dap.stats --param groupBy=source"
          ]
        },
        "mcp": {
          "enabled": false,
          "description": "Aggregate metrics and pattern detection across debug sessions with optional ASCII charts",
          "timeout": 30000,
          "relationships": {
            "requires": [],
            "recommended": [],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_NO_DATA",
                "summary": "No data available for statistical analysis",
                "is_retryable": false,
                "user_fix_hint": "Start debug sessions to generate data, or check sessionId parameter"
              },
              {
                "code": "E_INVALID_GROUP_BY",
                "summary": "Invalid groupBy parameter value",
                "is_retryable": true,
                "user_fix_hint": "Use valid groupBy values: category, source, hour, session"
              }
            ]
          },
          "safety": {
            "idempotent": true,
            "read_only": true,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Statistical analysis of debug output patterns\n- Aggregate metrics across single or multiple sessions\n- Visualizing output distribution with ASCII charts\n- Pattern detection (output frequency by category/source/time)\n\nDON'T USE FOR:\n- Viewing raw log content (use dap.logs)\n- Searching for specific patterns (use dap.search)\n- Comparing two specific sessions (use dap.compare)\n- Exception-focused analysis (use dap.exceptions)\n\nPREREQUISITES:\n- At least one debug session with captured data\n- For cross-session stats, use sessionId=all\n\nSAFETY:\n- Read-only operation (no state changes)\n- Idempotent (same query returns same results)\n",
            "parameter_hints": {
              "sessionId": {
                "description": "Session to analyze (or 'all' for cross-session stats)",
                "required": false,
                "examples": [
                  "latest",
                  "abc-123-def",
                  "all"
                ],
                "note": "Defaults to latest session, use 'all' for aggregate stats"
              },
              "groupBy": {
                "description": "How to group statistics for analysis",
                "required": false,
                "examples": [
                  "category",
                  "source",
                  "hour"
                ],
                "note": "category=by output type, source=by file, hour=by time, session=across sessions"
              },
              "includeCharts": {
                "description": "Generate ASCII charts for visualization",
                "required": false,
                "examples": [
                  "true",
                  "false"
                ],
                "note": "Default is true, set to false for raw numbers only"
              }
            }
          }
        }
      },
      "scriptRelPath": "dap/stats.js"
    },
    "dap.summary": {
      "metadata": {
        "alias": "dap.summary",
        "category": "dap",
        "description": "Get session overview with counts, metrics, and health indicators",
        "dangerOnly": false,
        "params": {
          "sessionId": {
            "type": "string",
            "required": false,
            "description": "Debug session ID (defaults to latest session)"
          },
          "compact": {
            "type": "boolean",
            "required": false,
            "default": false,
            "description": "Show condensed one-line summary"
          }
        },
        "response": "query",
        "errors": [
          "E_NO_SESSION",
          "E_INVALID_SESSION_ID"
        ],
        "cli": {
          "command": "dap summary",
          "description": "Quick overview of debug session health",
          "examples": [
            "vscb script run dap.summary",
            "vscb script run dap.summary --param sessionId=abc-123",
            "vscb script run dap.summary --param compact=true"
          ]
        },
        "mcp": {
          "enabled": false,
          "description": "Get debug session overview with counts, metrics, and health indicators for quick diagnosis",
          "timeout": 30000,
          "relationships": {
            "requires": [],
            "recommended": [],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_NO_SESSION",
                "summary": "No debug session found",
                "is_retryable": false,
                "user_fix_hint": "Start a debug session first or specify a valid sessionId"
              },
              {
                "code": "E_INVALID_SESSION_ID",
                "summary": "Specified session ID does not exist",
                "is_retryable": false,
                "user_fix_hint": "Check available sessions or omit sessionId to use latest"
              }
            ]
          },
          "safety": {
            "idempotent": true,
            "read_only": true,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Quick health check of debug session\n- Getting output counts and metrics overview\n- Understanding session scope before detailed analysis\n- Identifying anomalies (high exception count, unusual output volumes)\n\nDON'T USE FOR:\n- Viewing actual log content (use dap.logs)\n- Detailed exception analysis (use dap.exceptions)\n- Chronological event inspection (use dap.timeline)\n- Comparing multiple sessions (use dap.compare)\n\nPREREQUISITES:\n- At least one debug session must have been captured\n- For specific session, sessionId must be valid\n\nSAFETY:\n- Read-only operation (no state changes)\n- Idempotent (same query returns same results)\n",
            "parameter_hints": {
              "sessionId": {
                "description": "Debug session to summarize",
                "required": false,
                "examples": [
                  "latest",
                  "abc-123-def",
                  "null (defaults to latest)"
                ],
                "note": "Defaults to most recent session if omitted"
              },
              "compact": {
                "description": "Show condensed one-line summary instead of full breakdown",
                "required": false,
                "examples": [
                  "true",
                  "false"
                ],
                "note": "Use for quick overview, default is false (full details)"
              }
            }
          }
        }
      },
      "scriptRelPath": "dap/summary.js"
    },
    "dap.timeline": {
      "metadata": {
        "alias": "dap.timeline",
        "category": "dap",
        "description": "View chronological event stream with timestamps and milestones",
        "dangerOnly": false,
        "params": {
          "sessionId": {
            "type": "string",
            "required": false,
            "description": "Debug session ID (defaults to latest session)"
          },
          "eventTypes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "required": false,
            "description": "Event types to include (output, exception, stopped, exit)"
          },
          "window": {
            "type": "number",
            "required": false,
            "description": "Time window in milliseconds (null = show all)"
          },
          "granularity": {
            "type": "enum",
            "values": [
              "all",
              "summary",
              "milestones"
            ],
            "required": false,
            "default": "all",
            "description": "Level of detail (all=every event, summary=per-second groups, milestones=key events only)"
          },
          "fromEnd": {
            "type": "boolean",
            "required": false,
            "default": false,
            "description": "Measure window from session end instead of start"
          }
        },
        "response": "query",
        "errors": [
          "E_NO_SESSION",
          "E_NO_EVENTS"
        ],
        "cli": {
          "command": "dap timeline",
          "description": "View chronological event timeline",
          "examples": [
            "vscb script run dap.timeline",
            "vscb script run dap.timeline --param window=5000 --param fromEnd=true",
            "vscb script run dap.timeline --param granularity=milestones"
          ]
        },
        "mcp": {
          "enabled": false,
          "description": "View chronological timeline of debug session events with timestamps and milestones",
          "timeout": 20000,
          "relationships": {
            "requires": [
              "debug.start"
            ],
            "recommended": [],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_NO_SESSION",
                "summary": "No debug session found",
                "is_retryable": false,
                "user_fix_hint": "Call debug.start first to create an active session"
              },
              {
                "code": "E_NO_EVENTS",
                "summary": "No events captured for specified session",
                "is_retryable": false,
                "user_fix_hint": "Ensure session has run and generated events"
              }
            ]
          },
          "safety": {
            "idempotent": true,
            "read_only": true,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Viewing chronological sequence of debug events\n- Understanding session flow and execution path\n- Identifying timing issues or event gaps\n- Focusing on milestones (breakpoint hits, exceptions, exit)\n\nDON'T USE FOR:\n- Viewing raw console output (use dap.logs)\n- Statistical analysis of events (use dap.stats)\n- Comparing event sequences across sessions (use dap.compare)\n- Exception-focused analysis (use dap.exceptions)\n\nPREREQUISITES:\n- Active or completed debug session with events\n- Session must have been started with debug.start\n\nSAFETY:\n- Read-only operation (no state changes)\n- Idempotent (same query returns same results)\n",
            "parameter_hints": {
              "sessionId": {
                "description": "Debug session to view timeline for",
                "required": false,
                "examples": [
                  "latest",
                  "abc-123-def",
                  "null (defaults to latest)"
                ],
                "note": "Defaults to most recent session if omitted"
              },
              "eventTypes": {
                "description": "Event types to include in timeline",
                "required": false,
                "examples": [
                  "[\"output\", \"exception\"]",
                  "[\"stopped\", \"exit\"]",
                  "[\"output\"]"
                ],
                "note": "Omit to include all event types"
              },
              "window": {
                "description": "Time window in milliseconds to display",
                "required": false,
                "examples": [
                  "5000 (5 seconds)",
                  "10000 (10 seconds)",
                  "null (show all events)"
                ],
                "note": "Use with fromEnd to show last N milliseconds"
              },
              "granularity": {
                "description": "Level of detail for event display",
                "required": false,
                "examples": [
                  "all",
                  "summary",
                  "milestones"
                ],
                "note": "all=every event, summary=grouped, milestones=key events only"
              },
              "fromEnd": {
                "description": "Measure window from session end instead of start",
                "required": false,
                "examples": [
                  "true",
                  "false"
                ],
                "note": "Useful with window parameter for 'last N seconds' view"
              }
            }
          }
        }
      },
      "scriptRelPath": "dap/timeline.js"
    },
    "debug.continue": {
      "metadata": {
        "alias": "debug.continue",
        "name": "Continue Debug Execution",
        "category": "debug",
        "description": "Continue execution until next breakpoint hit or program exit",
        "dangerOnly": false,
        "params": {
          "sessionId": {
            "type": "string",
            "required": false,
            "description": "Debug session ID (defaults to active session)"
          },
          "timeoutMs": {
            "type": "number",
            "required": false,
            "default": 30000,
            "description": "Maximum time to wait for next event (in milliseconds)"
          }
        },
        "response": "waitable",
        "errors": [
          "E_TIMEOUT",
          "E_NO_SESSION",
          "E_ABORTED"
        ],
        "cli": {
          "command": "debug continue",
          "description": "Continue debug execution",
          "examples": [
            "vscb script run debug.continue",
            "vscb script run debug.continue --param timeoutMs=60000"
          ]
        },
        "mcp": {
          "enabled": true,
          "description": "Resume program execution from paused state, running until next breakpoint or program exit",
          "timeout": 10000,
          "relationships": {
            "requires": [
              "debug.start"
            ],
            "recommended": [],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_NO_SESSION",
                "summary": "No active debug session",
                "is_retryable": false,
                "user_fix_hint": "Call debug.start first to create debug session"
              },
              {
                "code": "E_TIMEOUT",
                "summary": "Execution did not hit breakpoint or exit within timeout",
                "is_retryable": true,
                "user_fix_hint": "Increase timeoutMs parameter or verify breakpoint is reachable"
              }
            ]
          },
          "safety": {
            "idempotent": false,
            "read_only": false,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Resuming execution after hitting breakpoint\n- Running program until next breakpoint\n- Continuing after step operation\n\nDON'T USE FOR:\n- Starting new session (use debug.start instead)\n- Stepping through code line-by-line (use debug.step-over instead)\n- Stopping execution (use debug.stop instead)\n\nPREREQUISITES:\n- Active debug session from debug.start\n- Session must be paused at breakpoint\n\nSAFETY:\n- Not idempotent (continuing twice advances execution twice)\n- Modifies execution state (resumes program)\n- Medium timeout (10s default)\n",
            "parameter_hints": {
              "sessionId": {
                "description": "ID of debug session (defaults to active session)",
                "required": false,
                "examples": [
                  "abc-123",
                  "",
                  "session-456"
                ],
                "note": "Omit to use currently active session"
              },
              "timeoutMs": {
                "description": "Maximum milliseconds to wait for next event (breakpoint hit or exit)",
                "required": false,
                "examples": [
                  "30000",
                  "60000",
                  "10000"
                ],
                "note": "Default 30000ms, increase if program takes long time to hit next breakpoint"
              }
            }
          }
        }
      },
      "scriptRelPath": "debug/continue.js"
    },
    "debug.evaluate": {
      "metadata": {
        "alias": "debug.evaluate",
        "name": "Evaluate Expression",
        "category": "debug",
        "description": "Evaluate an expression in debug context",
        "dangerOnly": false,
        "params": {
          "expression": {
            "type": "string",
            "required": true,
            "description": "Expression to evaluate"
          },
          "frameId": {
            "type": "number",
            "required": false,
            "description": "Frame ID for evaluation context (defaults to top frame)"
          },
          "context": {
            "type": "enum",
            "values": [
              "repl",
              "watch",
              "hover"
            ],
            "required": false,
            "description": "Evaluation context (defaults to repl)"
          },
          "sessionId": {
            "type": "string",
            "required": false,
            "description": "Debug session ID (defaults to active session)"
          }
        },
        "response": "query",
        "result": {
          "result": {
            "type": "string",
            "description": "Evaluation result as string"
          },
          "type": {
            "type": "string",
            "description": "Type of the result"
          },
          "variablesReference": {
            "type": "number",
            "description": "Reference for retrieving child variables if result is structured"
          },
          "namedVariables": {
            "type": "number",
            "description": "Number of named child variables"
          },
          "indexedVariables": {
            "type": "number",
            "description": "Number of indexed child variables"
          }
        },
        "errors": [
          "E_NO_SESSION",
          "E_INVALID_EXPRESSION",
          "E_INTERNAL"
        ],
        "cli": {
          "command": "debug evaluate",
          "description": "Evaluate expression in debug context",
          "examples": [
            "vscb script run debug.evaluate --param expression=\"x * 2\"",
            "vscb script run debug.evaluate --param expression=\"myObject.property\" --param frameId=0",
            "vscb script run debug.evaluate --param expression=\"array[0]\" --param context=watch"
          ]
        },
        "mcp": {
          "enabled": true,
          "description": "Evaluate expression in current debug context (supports expressions in any running language)",
          "timeout": 10000,
          "relationships": {
            "requires": [
              "debug.start"
            ],
            "recommended": [
              "breakpoint.set"
            ],
            "provides": [
              "evaluationResult"
            ],
            "conflicts": []
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_NO_SESSION",
                "summary": "No active debug session",
                "is_retryable": false,
                "user_fix_hint": "Call debug.start first to create debug session"
              },
              {
                "code": "E_INVALID_EXPRESSION",
                "summary": "Expression syntax error or invalid in current context",
                "is_retryable": true,
                "user_fix_hint": "Check expression syntax for current language and ensure variables are in scope"
              }
            ]
          },
          "safety": {
            "idempotent": true,
            "read_only": true,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Evaluating expressions at current execution point (variables, function calls, complex expressions)\n- Computing derived values from current program state\n- Testing conditions or function calls without modifying code\n- Inspecting object properties or array elements dynamically\n\nDON'T USE FOR:\n- Reading simple variable values (use debug.get-variable or debug.list-variables instead)\n- Modifying variable values (use debug.set-variable instead)\n- Evaluating when no session exists (call debug.start first)\n\nPREREQUISITES:\n- Active debug session must exist (debug.start)\n- Program should be paused at breakpoint for meaningful results\n- Expression must be valid in current frame's language and scope\n\nSAFETY:\n- Read-only operation (expression evaluation doesn't modify state)\n- Idempotent (same expression returns same result at same execution point)\n",
            "parameter_hints": {
              "expression": {
                "description": "Expression to evaluate in current language syntax",
                "required": true,
                "examples": [
                  "x * 2",
                  "myObject.property",
                  "array[0]"
                ],
                "language_specific": {
                  "python": "Use Python syntax: obj['key'], len(array), str(x)",
                  "javascript": "Use JavaScript syntax: obj.key, array.length, String(x)",
                  "csharp": "Use C# syntax: obj.Property, array.Length, x.ToString()",
                  "java": "Use Java syntax: obj.getProperty(), array.length, String.valueOf(x)"
                },
                "pitfalls": [
                  "Don't use expressions with side effects (they will execute and affect program state)",
                  "Avoid very expensive computations (they will block debugger)"
                ]
              },
              "frameId": {
                "description": "Frame ID for evaluation context (0 = top frame, 1 = caller, etc.)",
                "required": false,
                "examples": [
                  "0",
                  "1",
                  "2"
                ],
                "note": "Defaults to top frame (most recent call) if omitted"
              },
              "context": {
                "description": "Evaluation context type (affects how debugger formats results)",
                "required": false,
                "examples": [
                  "repl",
                  "watch",
                  "hover"
                ],
                "note": "Use 'repl' for interactive evaluation, 'watch' for variable tracking"
              },
              "sessionId": {
                "description": "Debug session identifier to target specific session",
                "required": false,
                "examples": [
                  "3f1a2c1e-b4d5-4e6f-a7b8-c9d0e1f2a3b4",
                  "active"
                ],
                "note": "Defaults to active session if omitted"
              }
            }
          }
        }
      },
      "scriptRelPath": "debug/evaluate.js"
    },
    "debug.get-variable": {
      "metadata": {
        "alias": "debug.get-variable",
        "category": "debug",
        "description": "Get children of a single variable with pagination support",
        "dangerOnly": false,
        "params": {
          "variablesReference": {
            "type": "number",
            "required": true,
            "description": "Reference ID for the variable container (from list-variables)"
          },
          "start": {
            "type": "number",
            "required": false,
            "default": 0,
            "description": "Starting index for pagination (0-based)"
          },
          "count": {
            "type": "number",
            "required": false,
            "default": 100,
            "description": "Number of children to retrieve"
          },
          "filter": {
            "type": "enum",
            "values": [
              "indexed",
              "named",
              "all"
            ],
            "required": false,
            "default": "all",
            "description": "Filter children by type (indexed for array elements, named for object properties, all for both)"
          }
        },
        "response": "query",
        "errors": [
          "E_NO_SESSION",
          "E_INVALID_PARAMS",
          "E_UNSUPPORTED_LANGUAGE",
          "E_INVALID_REFERENCE",
          "E_UNKNOWN"
        ],
        "cli": {
          "command": "debug get-variable",
          "description": "Get children of a single variable with pagination",
          "examples": [
            "vscb script debug/get-variable --param variablesReference=123",
            "vscb script debug/get-variable --param variablesReference=123 --param start=0 --param count=50",
            "vscb script debug/get-variable --param variablesReference=123 --param filter=indexed"
          ]
        },
        "mcp": {
          "enabled": true,
          "description": "Retrieve children of a single variable (object properties, array elements) with pagination support",
          "timeout": 10000,
          "relationships": {
            "requires": [
              "debug.start"
            ],
            "recommended": [
              "breakpoint.set"
            ],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_NO_SESSION",
                "summary": "No active debug session",
                "is_retryable": false,
                "user_fix_hint": "Call debug.start first to create debug session"
              },
              {
                "code": "E_INVALID_REFERENCE",
                "summary": "Invalid variablesReference ID",
                "is_retryable": false,
                "user_fix_hint": "Get valid variablesReference from debug.list-variables or debug.evaluate"
              }
            ]
          },
          "safety": {
            "idempotent": true,
            "read_only": true,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Expanding object properties or array elements from a variable reference\n- Paginating through large arrays or objects (use start/count)\n- Filtering indexed vs named children in structured data\n- Drilling into nested data structures incrementally\n\nDON'T USE FOR:\n- Getting top-level variables in current scope (use debug.list-variables instead)\n- Evaluating expressions (use debug.evaluate instead)\n- Simple variable inspection (use debug.list-variables with maxDepth)\n\nPREREQUISITES:\n- Active debug session must exist (debug.start)\n- Valid variablesReference ID (from debug.list-variables or debug.evaluate)\n- Program should be paused at breakpoint\n\nSAFETY:\n- Read-only operation (doesn't modify variable values)\n- Idempotent (returns same children for same reference)\n",
            "parameter_hints": {
              "variablesReference": {
                "description": "Reference ID for the variable container (from debug.list-variables or debug.evaluate)",
                "required": true,
                "examples": [
                  "123",
                  "456",
                  "789"
                ],
                "note": "Get this ID from variablesReference field in other debug tool outputs"
              },
              "start": {
                "description": "Starting index for pagination (0-based)",
                "required": false,
                "examples": [
                  "0",
                  "100",
                  "500"
                ],
                "note": "Use with count for paginating large arrays/objects"
              },
              "count": {
                "description": "Number of children to retrieve (default 100)",
                "required": false,
                "examples": [
                  "50",
                  "100",
                  "500"
                ],
                "note": "Lower values reduce response size, higher values reduce round trips"
              },
              "filter": {
                "description": "Filter children by type (indexed=array elements, named=object properties, all=both)",
                "required": false,
                "examples": [
                  "indexed",
                  "named",
                  "all"
                ],
                "note": "Use 'indexed' for arrays, 'named' for objects, 'all' for mixed structures"
              }
            }
          }
        }
      },
      "scriptRelPath": "debug/get-variable.js"
    },
    "debug.list-variables": {
      "metadata": {
        "alias": "debug.list-variables",
        "category": "debug",
        "description": "List variables at the current debug stop with depth control",
        "dangerOnly": false,
        "params": {
          "scope": {
            "type": "enum",
            "values": [
              "local",
              "closure",
              "global",
              "all"
            ],
            "required": false,
            "default": "all",
            "description": "Variable scope (local, closure, global, or all)"
          },
          "maxDepth": {
            "type": "number",
            "required": false,
            "default": 3,
            "description": "Maximum depth for variable tree traversal (0-10)"
          }
        },
        "response": "query",
        "errors": [
          "E_NO_SESSION",
          "E_UNSUPPORTED_LANGUAGE",
          "E_UNKNOWN"
        ],
        "cli": {
          "command": "debug list-variables",
          "description": "List debug variables with depth control",
          "examples": [
            "vscb script debug/list-variables",
            "vscb script debug/list-variables --param scope=local",
            "vscb script debug/list-variables --param scope=local --param maxDepth=2"
          ]
        },
        "mcp": {
          "enabled": true,
          "description": "List all variables in scope (local, closure, global) with configurable depth traversal",
          "timeout": 10000,
          "relationships": {
            "requires": [
              "debug.start"
            ],
            "recommended": [
              "breakpoint.set"
            ],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_NO_SESSION",
                "summary": "No active debug session",
                "is_retryable": false,
                "user_fix_hint": "Call debug.start first to create debug session"
              },
              {
                "code": "E_UNSUPPORTED_LANGUAGE",
                "summary": "Language adapter doesn't support variable listing",
                "is_retryable": false,
                "user_fix_hint": "Check if current language debugger supports DAP scopes request"
              }
            ]
          },
          "safety": {
            "idempotent": true,
            "read_only": true,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Listing all variables in current scope when paused at breakpoint\n- Inspecting local, closure, and global variables together\n- Getting overview of program state at current execution point\n- Discovering available variables before evaluation\n\nDON'T USE FOR:\n- Expanding deeply nested structures (use debug.get-variable with pagination)\n- Evaluating complex expressions (use debug.evaluate instead)\n- Getting variables from specific frame (use debug.scopes first)\n\nPREREQUISITES:\n- Active debug session must exist (debug.start)\n- Program should be paused at breakpoint for meaningful results\n- Language debugger must support DAP scopes/variables protocol\n\nSAFETY:\n- Read-only operation (doesn't modify variable values)\n- Idempotent (returns same variables at same execution point)\n",
            "parameter_hints": {
              "scope": {
                "description": "Variable scope filter (local, closure, global, or all)",
                "required": false,
                "examples": [
                  "local",
                  "closure",
                  "global"
                ],
                "note": "Defaults to 'all' which includes all scopes"
              },
              "maxDepth": {
                "description": "Maximum depth for nested object/array traversal (0-10)",
                "required": false,
                "examples": [
                  "1",
                  "3",
                  "5"
                ],
                "note": "Higher values fetch more nested data but increase response size; default is 3",
                "pitfalls": [
                  "Don't use maxDepth > 5 for large objects (response may timeout)",
                  "Use maxDepth=0 to get only top-level variables without expansion"
                ]
              }
            }
          }
        }
      },
      "scriptRelPath": "debug/list-variables.js"
    },
    "debug.restart": {
      "metadata": {
        "alias": "debug.restart",
        "name": "Restart Debug Session",
        "category": "debug",
        "description": "Restart the active or specified debug session",
        "dangerOnly": false,
        "params": {
          "sessionId": {
            "type": "string",
            "required": false,
            "description": "Debug session ID (defaults to active session)"
          }
        },
        "response": "action",
        "result": {
          "restarted": {
            "type": "boolean",
            "description": "Whether the session was successfully restarted"
          },
          "sessionId": {
            "type": "string",
            "description": "ID of the restarted session"
          }
        },
        "errors": [
          "E_NO_SESSION"
        ],
        "cli": {
          "command": "debug restart",
          "description": "Restart debug session",
          "examples": [
            "vscb script run debug.restart",
            "vscb script run debug.restart --param sessionId=abc-123"
          ]
        },
        "mcp": {
          "enabled": true,
          "description": "Restart the active debug session, performing a stop and start cycle to reload code changes",
          "timeout": 60000,
          "relationships": {
            "requires": [
              "debug.start"
            ],
            "recommended": [],
            "provides": [
              "debugSessionId"
            ],
            "conflicts": []
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_NO_SESSION",
                "summary": "No active debug session to restart",
                "is_retryable": false,
                "user_fix_hint": "Call debug.start first to create initial session"
              }
            ]
          },
          "safety": {
            "idempotent": false,
            "read_only": false,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Reloading code changes during debug session\n- Resetting program state while keeping breakpoints\n- Quickly restarting without manual stop/start\n\nDON'T USE FOR:\n- Starting initial session (use debug.start instead)\n- Continuing execution (use debug.continue instead)\n- Stopping permanently (use debug.stop instead)\n\nPREREQUISITES:\n- Active debug session from debug.start\n\nSAFETY:\n- Not idempotent (restarting multiple times has side effects)\n- Modifies debugger state (cycles session)\n- Long operation (60s timeout for stop+start)\n",
            "parameter_hints": {
              "sessionId": {
                "description": "ID of debug session to restart (defaults to active session)",
                "required": false,
                "examples": [
                  "abc-123",
                  "",
                  "session-456"
                ],
                "note": "Omit to restart currently active session"
              }
            }
          }
        }
      },
      "scriptRelPath": "debug/restart.js"
    },
    "debug.save-variable": {
      "metadata": {
        "alias": "debug.save-variable",
        "name": "Save Variable",
        "category": "debug",
        "description": "Save large variable data to file in JSON Lines format",
        "dangerOnly": false,
        "params": {
          "outputPath": {
            "type": "string",
            "required": true,
            "description": "Path to output file (JSONL format)"
          },
          "expression": {
            "type": "string",
            "required": true,
            "description": "Expression to evaluate and save (e.g., \"largeArray\", \"user\")"
          },
          "pageSize": {
            "type": "number",
            "required": false,
            "default": 500,
            "description": "Number of items to fetch per page"
          },
          "maxItems": {
            "type": "number",
            "required": false,
            "description": "Maximum number of items to save (omit for unlimited)"
          },
          "context": {
            "type": "string",
            "required": false,
            "default": "watch",
            "description": "Evaluation context (watch, repl, hover, etc.)"
          }
        },
        "response": "query",
        "result": {
          "success": {
            "type": "boolean",
            "description": "Whether the operation succeeded"
          },
          "outputPath": {
            "type": "string",
            "description": "Path where variable data was saved"
          },
          "bytes": {
            "type": "number",
            "description": "Total bytes written to file"
          },
          "counts": {
            "type": "object",
            "description": "Count of named and indexed children saved"
          }
        },
        "errors": [
          "E_NO_SESSION",
          "E_NO_THREADS",
          "E_NO_STACK",
          "E_NOT_STOPPED",
          "E_EVALUATE_FAILED",
          "E_NOT_EXPANDABLE"
        ],
        "cli": {
          "command": "vscb script run debug.save-variable",
          "description": "Save large variable data to file",
          "examples": [
            "vscb script run debug.save-variable --param expression=\"largeArray\" --param outputPath=\"/tmp/vars.jsonl\"",
            "vscb script run debug.save-variable --param expression=\"user\" --param outputPath=\"./user.jsonl\" --param pageSize=100",
            "vscb script run debug.save-variable --param expression=\"data\" --param outputPath=\"/tmp/data.jsonl\" --param maxItems=1000"
          ]
        },
        "mcp": {
          "enabled": true,
          "description": "Save large variable structures (arrays, objects) to disk as JSON Lines with pagination",
          "timeout": 30000,
          "relationships": {
            "requires": [
              "debug.start"
            ],
            "recommended": [
              "breakpoint.set"
            ],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_NO_SESSION",
                "summary": "No active debug session",
                "is_retryable": false,
                "user_fix_hint": "Call debug.start first to create debug session"
              },
              {
                "code": "E_NOT_STOPPED",
                "summary": "Program is running, cannot save variables",
                "is_retryable": true,
                "user_fix_hint": "Set breakpoint and wait for pause before saving variables"
              },
              {
                "code": "E_EVALUATE_FAILED",
                "summary": "Expression could not be evaluated or found",
                "is_retryable": false,
                "user_fix_hint": "Verify expression syntax and that variable exists in current scope"
              }
            ]
          },
          "safety": {
            "idempotent": false,
            "read_only": false,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Saving large arrays or objects to file for offline analysis\n- Exporting debug data that's too large for console display\n- Creating snapshots of runtime state at specific execution points\n- Analyzing data structures with external tools (jq, grep, etc.)\n\nDON'T USE FOR:\n- Reading small variables (use debug.list-variables or debug.evaluate)\n- Modifying variable values (use debug.set-variable instead)\n- Real-time variable inspection (use debug.get-variable with pagination)\n\nPREREQUISITES:\n- Active debug session must exist (debug.start)\n- Program must be paused at breakpoint\n- Expression must evaluate to expandable structure (object/array)\n- Output path must be writable\n\nSAFETY:\n- Writes to filesystem (creates/overwrites file)\n- Not idempotent (repeated calls overwrite file)\n- Not destructive (only affects file, not program state)\n",
            "parameter_hints": {
              "outputPath": {
                "description": "Path to output file (JSON Lines format, .jsonl extension)",
                "required": true,
                "examples": [
                  "/tmp/vars.jsonl",
                  "./debug-data.jsonl",
                  "/Users/username/data.jsonl"
                ],
                "note": "File will be created or overwritten; use absolute or workspace-relative paths",
                "pitfalls": [
                  "Don't use paths without write permissions",
                  "File is overwritten if it exists (no append mode)"
                ]
              },
              "expression": {
                "description": "Expression to evaluate and save (must resolve to object or array)",
                "required": true,
                "examples": [
                  "largeArray",
                  "user",
                  "dataStructure"
                ],
                "note": "Expression must evaluate to expandable structure with children",
                "pitfalls": [
                  "Don't use primitive values (string, number, boolean) - must be object/array"
                ]
              },
              "pageSize": {
                "description": "Number of items to fetch per page (affects memory usage)",
                "required": false,
                "examples": [
                  "100",
                  "500",
                  "1000"
                ],
                "note": "Default is 500; lower values reduce memory usage, higher values improve speed"
              },
              "maxItems": {
                "description": "Maximum number of items to save (omit for unlimited)",
                "required": false,
                "examples": [
                  "1000",
                  "5000",
                  "10000"
                ],
                "note": "Use to limit output size when dealing with very large structures"
              },
              "context": {
                "description": "Evaluation context for expression (affects how debugger fetches data)",
                "required": false,
                "examples": [
                  "watch",
                  "repl"
                ],
                "note": "Default is 'watch'; use 'repl' for different formatting"
              }
            }
          }
        }
      },
      "scriptRelPath": "debug/save-variable.js"
    },
    "debug.scopes": {
      "metadata": {
        "alias": "debug.scopes",
        "name": "List Scopes",
        "category": "debug",
        "description": "List available scopes for a given frame",
        "dangerOnly": false,
        "params": {
          "frameId": {
            "type": "number",
            "required": true,
            "description": "Frame ID to get scopes for"
          },
          "sessionId": {
            "type": "string",
            "required": false,
            "description": "Debug session ID (defaults to active session)"
          }
        },
        "response": "query",
        "result": {
          "scopes": {
            "type": "array",
            "description": "List of available scopes",
            "items": {
              "name": {
                "type": "string",
                "description": "Scope name (e.g., Locals, Globals)"
              },
              "variablesReference": {
                "type": "number",
                "description": "Reference for retrieving variables"
              },
              "expensive": {
                "type": "boolean",
                "description": "Whether fetching variables is expensive"
              },
              "namedVariables": {
                "type": "number",
                "description": "Number of named variables"
              },
              "indexedVariables": {
                "type": "number",
                "description": "Number of indexed variables"
              }
            }
          }
        },
        "errors": [
          "E_NO_SESSION",
          "E_INTERNAL"
        ],
        "cli": {
          "command": "debug scopes",
          "description": "List scopes for a frame",
          "examples": [
            "vscb script run debug.scopes --param frameId=0",
            "vscb script run debug.scopes --param frameId=1 --param sessionId=abc-123"
          ]
        },
        "mcp": {
          "enabled": true,
          "description": "List available scopes (Local, Global, Closure) for a specific stack frame during debugging",
          "timeout": 5000,
          "relationships": {
            "requires": [
              "debug.start"
            ],
            "recommended": [
              "breakpoint.set",
              "debug.stack"
            ],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_NO_SESSION",
                "summary": "No active debug session",
                "is_retryable": false,
                "user_fix_hint": "Call debug.start first to create debug session"
              },
              {
                "code": "E_INTERNAL",
                "summary": "Invalid frame ID or debugger error",
                "is_retryable": true,
                "user_fix_hint": "Get valid frame ID from debug.stack and retry"
              }
            ]
          },
          "safety": {
            "idempotent": true,
            "read_only": true,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Discovering available variable scopes for a stack frame\n- Getting variablesReference IDs for use with debug.list-variables\n- Understanding scope hierarchy (locals, closures, globals)\n- Preparing to list variables in specific scope\n\nDON'T USE FOR:\n- Directly listing variable values (use debug.list-variables instead)\n- Evaluating expressions (use debug.evaluate instead)\n- Getting stack frames (use debug.stack first to get frame IDs)\n\nPREREQUISITES:\n- Active debug session must exist (debug.start)\n- Program should be paused at breakpoint\n- Frame ID must be valid (get from debug.stack)\n\nSAFETY:\n- Read-only operation (doesn't modify program state)\n- Idempotent (returns same scopes for same frame)\n",
            "parameter_hints": {
              "frameId": {
                "description": "Stack frame ID to get scopes for (0 = top frame)",
                "required": true,
                "examples": [
                  "0",
                  "1",
                  "2"
                ],
                "note": "Get valid frame IDs from debug.stack output"
              },
              "sessionId": {
                "description": "Debug session ID (optional, defaults to active session)",
                "required": false,
                "examples": [
                  "abc-123-def",
                  "latest",
                  "session-xyz"
                ],
                "note": "Omit to use active session automatically"
              }
            }
          }
        }
      },
      "scriptRelPath": "debug/scopes.js"
    },
    "debug.set-variable": {
      "metadata": {
        "alias": "debug.set-variable",
        "category": "debug",
        "description": "Modify variable values during debugging",
        "dangerOnly": false,
        "params": {
          "name": {
            "type": "string",
            "required": true,
            "description": "Name of the variable to modify"
          },
          "value": {
            "type": "string",
            "required": true,
            "description": "New value as a string expression"
          },
          "variablesReference": {
            "type": "number",
            "required": false,
            "description": "Variables reference containing the variable (optional)"
          }
        },
        "response": "mutate",
        "errors": [
          "E_NO_SESSION",
          "E_NOT_PAUSED",
          "E_UNSUPPORTED_LANGUAGE",
          "E_VARIABLE_NOT_FOUND",
          "E_SET_FAILED"
        ],
        "cli": {
          "command": "debug set-variable",
          "description": "Modify variable values during debugging",
          "examples": [
            "vscb script debug/set-variable --param name=x --param value=42",
            "vscb script debug/set-variable --param name=obj.prop --param value='\"hello\"'"
          ]
        },
        "mcp": {
          "enabled": true,
          "description": "Modify variable values at current execution point (supports runtime value changes during debugging)",
          "timeout": 10000,
          "relationships": {
            "requires": [
              "debug.start"
            ],
            "recommended": [
              "debug.get-variable"
            ],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_NO_SESSION",
                "summary": "No active debug session",
                "is_retryable": false,
                "user_fix_hint": "Call debug.start first to create debug session"
              },
              {
                "code": "E_NOT_PAUSED",
                "summary": "Program is running, cannot modify variables",
                "is_retryable": true,
                "user_fix_hint": "Set breakpoint and wait for pause before modifying variables"
              },
              {
                "code": "E_VARIABLE_NOT_FOUND",
                "summary": "Variable name not found in current scope",
                "is_retryable": false,
                "user_fix_hint": "Use debug.list-variables to see available variables in current scope"
              }
            ]
          },
          "safety": {
            "idempotent": true,
            "read_only": false,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Modifying variable values during debugging to test different scenarios\n- Fixing incorrect values to continue execution past bugs\n- Testing edge cases by injecting specific values\n- Hot-fixing values without restarting debug session\n\nDON'T USE FOR:\n- Reading variable values (use debug.list-variables or debug.get-variable)\n- Evaluating expressions (use debug.evaluate instead)\n- Modifying constants or read-only values (will fail)\n\nPREREQUISITES:\n- Active debug session must exist (debug.start)\n- Program must be paused at breakpoint\n- Variable must exist in current scope and be writable\n- Value expression must be valid in current language\n\nSAFETY:\n- Modifies runtime state (changes variable values)\n- Idempotent (setting same value multiple times achieves same state)\n- Not destructive (can set back to original value)\n",
            "parameter_hints": {
              "name": {
                "description": "Name of the variable to modify (simple name or property path)",
                "required": true,
                "examples": [
                  "x",
                  "obj.property",
                  "array[0]"
                ],
                "note": "Use dot notation for nested properties in some languages",
                "pitfalls": [
                  "Don't use complex expressions here (just the variable name/path)"
                ]
              },
              "value": {
                "description": "New value as string expression in current language syntax",
                "required": true,
                "examples": [
                  "42",
                  "\"hello\"",
                  "true"
                ],
                "language_specific": {
                  "python": "Use Python literals: 42, 'hello', True, [1,2,3]",
                  "javascript": "Use JavaScript literals: 42, 'hello', true, [1,2,3]",
                  "csharp": "Use C# literals: 42, \"hello\", true",
                  "java": "Use Java literals: 42, \"hello\", true"
                },
                "pitfalls": [
                  "Don't forget quotes for string values",
                  "Value must be parseable by current language debugger"
                ]
              },
              "variablesReference": {
                "description": "Optional container reference if variable is nested in object/scope",
                "required": false,
                "examples": [
                  "123",
                  "456"
                ],
                "note": "Usually omit for top-level variables; get from debug.list-variables for nested variables"
              }
            }
          }
        }
      },
      "scriptRelPath": "debug/set-variable.js"
    },
    "debug.stack": {
      "metadata": {
        "alias": "debug.stack",
        "name": "Get Call Stack",
        "category": "debug",
        "description": "Get the current call stack frames",
        "dangerOnly": false,
        "params": {
          "sessionId": {
            "type": "string",
            "required": false,
            "description": "Debug session ID (defaults to active session)"
          }
        },
        "response": "query",
        "errors": [
          "E_NO_SESSION",
          "E_NOT_STOPPED"
        ],
        "cli": {
          "command": "debug stack",
          "description": "Get call stack frames",
          "examples": [
            "vscb script run debug.stack"
          ]
        },
        "mcp": {
          "enabled": true,
          "description": "Get the current call stack frames with function names, source locations, and frame IDs",
          "timeout": 5000,
          "relationships": {
            "requires": [
              "debug.start"
            ],
            "recommended": [
              "breakpoint.set"
            ],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_NO_SESSION",
                "summary": "No active debug session",
                "is_retryable": false,
                "user_fix_hint": "Call debug.start first to create debug session"
              },
              {
                "code": "E_NOT_STOPPED",
                "summary": "Program is running, not paused at breakpoint",
                "is_retryable": true,
                "user_fix_hint": "Set breakpoint and wait for execution to pause, or use debug.continue to resume"
              }
            ]
          },
          "safety": {
            "idempotent": true,
            "read_only": true,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Viewing call stack when paused at breakpoint\n- Understanding execution path and function call hierarchy\n- Getting frame IDs for use with debug.scopes or debug.evaluate\n- Diagnosing where execution stopped and how it got there\n\nDON'T USE FOR:\n- Listing variables (use debug.list-variables or debug.scopes instead)\n- Evaluating expressions (use debug.evaluate instead)\n- Checking if session exists (use debug.status instead)\n\nPREREQUISITES:\n- Active debug session must exist (debug.start)\n- Program should be paused at breakpoint for meaningful stack\n\nSAFETY:\n- Read-only operation (doesn't modify program state)\n- Idempotent (returns same stack at same execution point)\n",
            "parameter_hints": {
              "sessionId": {
                "description": "Debug session ID to query (optional, defaults to active session)",
                "required": false,
                "examples": [
                  "abc-123-def",
                  "session-xyz"
                ],
                "note": "Omit to use active session automatically"
              }
            }
          }
        }
      },
      "scriptRelPath": "debug/stack.js"
    },
    "debug.start": {
      "metadata": {
        "alias": "debug.start",
        "name": "Start Debug Session",
        "category": "debug",
        "description": "Start a debug session and wait until it's initialized",
        "dangerOnly": false,
        "params": {
          "launch": {
            "type": "string",
            "required": true,
            "description": "Launch configuration name from launch.json"
          },
          "folder": {
            "type": "string",
            "required": false,
            "description": "Workspace folder path (defaults to first workspace folder)"
          },
          "timeoutMs": {
            "type": "number",
            "required": false,
            "default": 30000,
            "description": "Maximum time to wait for session to start (in milliseconds)"
          },
          "wait": {
            "type": "boolean",
            "required": false,
            "default": false,
            "description": "Wait for breakpoint/error/exit after launch (like test.debug_single)"
          }
        },
        "response": "waitable",
        "errors": [
          "E_TIMEOUT",
          "E_LAUNCH_FAILED",
          "E_NOT_FOUND"
        ],
        "cli": {
          "command": "debug start",
          "description": "Start a debug session",
          "examples": [
            {
              "vscb script run debug.start --param launch=\"Python": "Debug Tests\""
            },
            "vscb script run debug.start --param launch=\"Node.js\" --param folder=/home/user/project"
          ]
        },
        "mcp": {
          "enabled": true,
          "description": "Start a new debug session using launch.json configuration, launching the runtime and loading symbols",
          "timeout": 60000,
          "relationships": {
            "requires": [],
            "recommended": [
              "breakpoint.set"
            ],
            "provides": [
              "debugSessionId"
            ],
            "conflicts": [
              "debug.start"
            ]
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_LAUNCH_FAILED",
                "summary": "Failed to launch debug session with specified configuration",
                "is_retryable": false,
                "user_fix_hint": "Verify launch.json exists and configuration name is correct"
              },
              {
                "code": "E_NOT_FOUND",
                "summary": "Launch configuration not found in launch.json",
                "is_retryable": false,
                "user_fix_hint": "Check that launch configuration name matches entry in launch.json"
              },
              {
                "code": "E_TIMEOUT",
                "summary": "Session startup exceeded timeout waiting for initialization",
                "is_retryable": true,
                "user_fix_hint": "Increase timeoutMs parameter to 60000ms or verify runtime is installed"
              }
            ]
          },
          "safety": {
            "idempotent": false,
            "read_only": false,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Starting a new debug session before setting breakpoints or stepping\n- Launching application with specific launch.json configuration\n- Beginning debug workflow when no session exists\n\nDON'T USE FOR:\n- Restarting existing session (use debug.restart instead)\n- Running tests (use test.debug-single instead)\n- Checking if session exists (use debug.status instead)\n\nPREREQUISITES:\n- Valid launch.json with named configuration\n- Runtime/debugger installed for target language\n- No conflicting debug session active\n\nSAFETY:\n- Not idempotent (starting twice creates issues)\n- Modifies debugger state (creates session)\n- Long operation (60s timeout)\n",
            "parameter_hints": {
              "launch": {
                "description": "Name of launch configuration from workspace launch.json",
                "required": true,
                "examples": [
                  "Python: Debug Tests",
                  "Node.js: Launch Program",
                  "Run Extension"
                ],
                "note": "Must match configuration name exactly (case-sensitive)",
                "pitfalls": [
                  "Don't use file paths - only configuration names from launch.json",
                  "Verify configuration exists before calling this tool"
                ]
              },
              "folder": {
                "description": "Workspace folder path containing launch.json (defaults to first workspace folder)",
                "required": false,
                "examples": [
                  "/home/user/my-project",
                  "/workspace/monorepo/package-a",
                  ""
                ],
                "note": "Omit for single-folder workspaces"
              },
              "timeoutMs": {
                "description": "Maximum milliseconds to wait for session initialization",
                "required": false,
                "examples": [
                  "30000",
                  "60000",
                  "90000"
                ],
                "note": "Default 30000ms may be too short for slow runtimes - increase to 60000ms for complex applications"
              },
              "wait": {
                "description": "Whether to wait for breakpoint/error/exit after launching (blocks until event)",
                "required": false,
                "examples": [
                  "false",
                  "true"
                ],
                "note": "Set to true to pause execution flow until significant event occurs"
              }
            }
          }
        }
      },
      "scriptRelPath": "debug/start.js"
    },
    "debug.status": {
      "metadata": {
        "alias": "debug.status",
        "name": "Debug Session Status",
        "category": "debug",
        "description": "Query comprehensive debugger status including session info, pause state, threads, stack frames, and scopes",
        "dangerOnly": false,
        "params": {},
        "response": "query",
        "errors": [
          "E_NO_SESSION",
          "E_NOT_STOPPED"
        ],
        "cli": {
          "command": "debug status",
          "description": "Get current debug session status",
          "examples": [
            "vscb script run debug.status"
          ]
        },
        "mcp": {
          "enabled": true,
          "description": "Get comprehensive debug session status including session info, pause state, threads, and scopes",
          "timeout": 5000,
          "relationships": {
            "requires": [
              "debug.start"
            ],
            "recommended": [],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_NO_SESSION",
                "summary": "No active debug session",
                "is_retryable": false,
                "user_fix_hint": "Call debug.start first to create debug session"
              },
              {
                "code": "E_NOT_STOPPED",
                "summary": "Program is running, cannot retrieve full status",
                "is_retryable": true,
                "user_fix_hint": "Set breakpoint and wait for pause, or check if session is still active"
              }
            ]
          },
          "safety": {
            "idempotent": true,
            "read_only": true,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Checking if debug session is active and paused\n- Getting comprehensive overview of current debug state\n- Retrieving session metadata (ID, configuration, threads)\n- Understanding execution state before other debug operations\n\nDON'T USE FOR:\n- Getting detailed stack trace (use debug.stack for better format)\n- Listing all variables (use debug.list-variables instead)\n- Evaluating expressions (use debug.evaluate instead)\n\nPREREQUISITES:\n- Active debug session must exist (debug.start)\n- Some information only available when paused at breakpoint\n\nSAFETY:\n- Read-only operation (doesn't modify program state)\n- Idempotent (returns same status at same execution point)\n",
            "parameter_hints": {}
          }
        }
      },
      "scriptRelPath": "debug/status.js"
    },
    "debug.step-into": {
      "metadata": {
        "alias": "debug.step-into",
        "name": "Step Into",
        "category": "debug",
        "description": "Step into the function call and wait until stopped",
        "dangerOnly": false,
        "params": {
          "sessionId": {
            "type": "string",
            "required": false,
            "description": "Debug session ID (defaults to active session)"
          },
          "timeoutMs": {
            "type": "number",
            "required": false,
            "default": 5000,
            "description": "Maximum time to wait for step to complete (in milliseconds)"
          }
        },
        "response": "waitable",
        "errors": [
          "E_TIMEOUT",
          "E_NO_SESSION"
        ],
        "cli": {
          "command": "debug step-into",
          "description": "Step into the function call",
          "examples": [
            "vscb script run debug.step-into"
          ]
        },
        "mcp": {
          "enabled": true,
          "description": "Execute current line and enter function calls, stopping at first line inside called function",
          "timeout": 10000,
          "relationships": {
            "requires": [
              "debug.start"
            ],
            "recommended": [],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_NO_SESSION",
                "summary": "No active debug session",
                "is_retryable": false,
                "user_fix_hint": "Call debug.start first to create debug session"
              },
              {
                "code": "E_TIMEOUT",
                "summary": "Step operation did not complete within timeout",
                "is_retryable": true,
                "user_fix_hint": "Increase timeoutMs parameter or verify program is not hanging"
              }
            ]
          },
          "safety": {
            "idempotent": false,
            "read_only": false,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Entering function calls to debug internal logic\n- Diving deeper into call hierarchy\n- Inspecting function implementation details\n\nDON'T USE FOR:\n- Staying in current scope (use debug.step-over instead)\n- Exiting current function (use debug.step-out instead)\n- Running to next breakpoint (use debug.continue instead)\n\nPREREQUISITES:\n- Active debug session from debug.start\n- Session must be paused at line with function call\n\nSAFETY:\n- Not idempotent (stepping twice moves twice)\n- Modifies execution state (advances program)\n- Quick operation (10s timeout)\n",
            "parameter_hints": {
              "sessionId": {
                "description": "ID of debug session (defaults to active session)",
                "required": false,
                "examples": [
                  "abc-123",
                  "",
                  "session-456"
                ],
                "note": "Omit to use currently active session"
              },
              "timeoutMs": {
                "description": "Maximum milliseconds to wait for step to complete",
                "required": false,
                "examples": [
                  "5000",
                  "10000",
                  "15000"
                ],
                "note": "Default 5000ms, increase if entering slow function"
              }
            }
          }
        }
      },
      "scriptRelPath": "debug/step-into.js"
    },
    "debug.step-out": {
      "metadata": {
        "alias": "debug.step-out",
        "name": "Step Out",
        "category": "debug",
        "description": "Step out of the current function and wait until stopped",
        "dangerOnly": false,
        "params": {
          "sessionId": {
            "type": "string",
            "required": false,
            "description": "Debug session ID (defaults to active session)"
          },
          "timeoutMs": {
            "type": "number",
            "required": false,
            "default": 5000,
            "description": "Maximum time to wait for step to complete (in milliseconds)"
          }
        },
        "response": "waitable",
        "errors": [
          "E_TIMEOUT",
          "E_NO_SESSION"
        ],
        "cli": {
          "command": "debug step-out",
          "description": "Step out of the current function",
          "examples": [
            "vscb script run debug.step-out"
          ]
        },
        "mcp": {
          "enabled": true,
          "description": "Execute until current function returns, stopping at the calling function's next line",
          "timeout": 10000,
          "relationships": {
            "requires": [
              "debug.start"
            ],
            "recommended": [],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_NO_SESSION",
                "summary": "No active debug session",
                "is_retryable": false,
                "user_fix_hint": "Call debug.start first to create debug session"
              },
              {
                "code": "E_TIMEOUT",
                "summary": "Step operation did not complete within timeout",
                "is_retryable": true,
                "user_fix_hint": "Increase timeoutMs parameter or verify function completes execution"
              }
            ]
          },
          "safety": {
            "idempotent": false,
            "read_only": false,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Exiting current function quickly after stepping in too deep\n- Returning to calling function's context\n- Skipping remaining lines in current function\n\nDON'T USE FOR:\n- Entering function calls (use debug.step-into instead)\n- Staying in current scope (use debug.step-over instead)\n- Running to next breakpoint (use debug.continue instead)\n\nPREREQUISITES:\n- Active debug session from debug.start\n- Session must be paused inside a function (not at top level)\n\nSAFETY:\n- Not idempotent (stepping twice moves twice)\n- Modifies execution state (advances program)\n- Quick operation (10s timeout)\n",
            "parameter_hints": {
              "sessionId": {
                "description": "ID of debug session (defaults to active session)",
                "required": false,
                "examples": [
                  "abc-123",
                  "",
                  "session-456"
                ],
                "note": "Omit to use currently active session"
              },
              "timeoutMs": {
                "description": "Maximum milliseconds to wait for step to complete",
                "required": false,
                "examples": [
                  "5000",
                  "10000",
                  "15000"
                ],
                "note": "Default 5000ms, increase if function takes long time to complete"
              }
            }
          }
        }
      },
      "scriptRelPath": "debug/step-out.js"
    },
    "debug.step-over": {
      "metadata": {
        "alias": "debug.step-over",
        "name": "Step Over",
        "category": "debug",
        "description": "Step over the current line and wait until stopped at the next line",
        "dangerOnly": false,
        "params": {
          "sessionId": {
            "type": "string",
            "required": false,
            "description": "Debug session ID (defaults to active session)"
          },
          "timeoutMs": {
            "type": "number",
            "required": false,
            "default": 5000,
            "description": "Maximum time to wait for step to complete (in milliseconds)"
          }
        },
        "response": "waitable",
        "errors": [
          "E_TIMEOUT",
          "E_NO_SESSION"
        ],
        "cli": {
          "command": "debug step-over",
          "description": "Step over the current line",
          "examples": [
            "vscb script run debug.step-over"
          ]
        },
        "mcp": {
          "enabled": true,
          "description": "Execute current line without entering function calls, stopping at next line in current scope",
          "timeout": 10000,
          "relationships": {
            "requires": [
              "debug.start"
            ],
            "recommended": [],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_NO_SESSION",
                "summary": "No active debug session",
                "is_retryable": false,
                "user_fix_hint": "Call debug.start first to create debug session"
              },
              {
                "code": "E_TIMEOUT",
                "summary": "Step operation did not complete within timeout",
                "is_retryable": true,
                "user_fix_hint": "Increase timeoutMs parameter or verify program is not hanging"
              }
            ]
          },
          "safety": {
            "idempotent": false,
            "read_only": false,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Advancing execution by one line without entering functions\n- Stepping over function calls to stay in current scope\n- Line-by-line debugging in current function\n\nDON'T USE FOR:\n- Entering function calls (use debug.step-into instead)\n- Exiting current function (use debug.step-out instead)\n- Running to next breakpoint (use debug.continue instead)\n\nPREREQUISITES:\n- Active debug session from debug.start\n- Session must be paused at breakpoint or after previous step\n\nSAFETY:\n- Not idempotent (stepping twice moves twice)\n- Modifies execution state (advances program)\n- Quick operation (10s timeout)\n",
            "parameter_hints": {
              "sessionId": {
                "description": "ID of debug session (defaults to active session)",
                "required": false,
                "examples": [
                  "abc-123",
                  "",
                  "session-456"
                ],
                "note": "Omit to use currently active session"
              },
              "timeoutMs": {
                "description": "Maximum milliseconds to wait for step to complete",
                "required": false,
                "examples": [
                  "5000",
                  "10000",
                  "15000"
                ],
                "note": "Default 5000ms, increase if stepping over slow line execution"
              }
            }
          }
        }
      },
      "scriptRelPath": "debug/step-over.js"
    },
    "debug.stop": {
      "metadata": {
        "alias": "debug.stop",
        "name": "Stop Debug Session",
        "category": "debug",
        "description": "Stop the active or specified debug session",
        "dangerOnly": false,
        "params": {
          "sessionId": {
            "type": "string",
            "required": false,
            "description": "Debug session ID (defaults to active session)"
          }
        },
        "response": "action",
        "result": {
          "status": {
            "type": "string",
            "description": "Session status after stopping"
          },
          "sessionId": {
            "type": "string",
            "description": "ID of the stopped session"
          }
        },
        "errors": [
          "E_NO_SESSION"
        ],
        "cli": {
          "command": "vscb script run debug.stop",
          "description": "Stop debug session",
          "examples": [
            "vscb script run debug.stop",
            "vscb script run debug.stop --param sessionId=abc-123"
          ]
        },
        "mcp": {
          "enabled": true,
          "description": "Stop the active debug session, terminating the debugged process and cleaning up resources",
          "timeout": 15000,
          "relationships": {
            "requires": [
              "debug.start"
            ],
            "recommended": [],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_NO_SESSION",
                "summary": "No active debug session to stop",
                "is_retryable": false,
                "user_fix_hint": "Call debug.start first or use debug.status to verify session exists"
              }
            ]
          },
          "safety": {
            "idempotent": false,
            "read_only": false,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Ending active debug session when finished debugging\n- Cleaning up before starting new session\n- Terminating debugged process\n\nDON'T USE FOR:\n- Restarting session (use debug.restart instead)\n- Pausing execution (use breakpoint.set instead)\n- Checking session status (use debug.status instead)\n\nPREREQUISITES:\n- Active debug session from debug.start\n\nSAFETY:\n- Not idempotent (stopping twice may error)\n- Modifies debugger state (destroys session)\n- Medium timeout (15s for cleanup)\n",
            "parameter_hints": {
              "sessionId": {
                "description": "ID of debug session to stop (defaults to active session)",
                "required": false,
                "examples": [
                  "abc-123",
                  "",
                  "session-456"
                ],
                "note": "Omit to stop currently active session"
              }
            }
          }
        }
      },
      "scriptRelPath": "debug/stop.js"
    },
    "debug.threads": {
      "metadata": {
        "alias": "debug.threads",
        "name": "Get Debug Threads",
        "category": "debug",
        "description": "Get information about active threads in the debug session",
        "dangerOnly": false,
        "params": {
          "sessionId": {
            "type": "string",
            "required": false,
            "description": "Debug session ID (defaults to active session)"
          }
        },
        "response": "query",
        "errors": [
          "E_NO_SESSION"
        ],
        "cli": {
          "command": "debug threads",
          "description": "Get debug thread information",
          "examples": [
            "vscb script run debug.threads"
          ]
        },
        "mcp": {
          "enabled": true,
          "description": "Get information about active threads (thread IDs, names, and current state) during debugging",
          "timeout": 5000,
          "relationships": {
            "requires": [
              "debug.start"
            ],
            "recommended": [],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_NO_SESSION",
                "summary": "No active debug session",
                "is_retryable": false,
                "user_fix_hint": "Call debug.start first to create debug session"
              }
            ]
          },
          "safety": {
            "idempotent": true,
            "read_only": true,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Listing all active threads in debug session\n- Getting thread IDs for multi-threaded debugging\n- Understanding which threads are running/stopped\n- Identifying main thread vs worker threads\n\nDON'T USE FOR:\n- Getting stack frames (use debug.stack instead)\n- Switching between threads (not supported by DAP directly)\n- Checking session status (use debug.status for comprehensive info)\n\nPREREQUISITES:\n- Active debug session must exist (debug.start)\n- Thread information updates as execution progresses\n\nSAFETY:\n- Read-only operation (doesn't modify program state)\n- Idempotent (returns same threads at same execution point)\n",
            "parameter_hints": {
              "sessionId": {
                "description": "Debug session ID (optional, defaults to active session)",
                "required": false,
                "examples": [
                  "abc-123-def",
                  "session-xyz"
                ],
                "note": "Omit to use active session automatically"
              }
            }
          }
        }
      },
      "scriptRelPath": "debug/threads.js"
    },
    "debug.tracker": {
      "metadata": {
        "alias": "debug.tracker",
        "name": "Debug Adapter Tracker",
        "category": "debug",
        "description": "Register DebugAdapterTrackerFactory to observe all DAP messages including capabilities, events, and breakpoint mappings",
        "dangerOnly": false,
        "params": {},
        "response": "query",
        "errors": [
          "E_NO_SESSION"
        ],
        "cli": {
          "command": "debug tracker",
          "description": "Track and observe Debug Adapter Protocol messages",
          "examples": [
            "vscb script run debug.tracker"
          ]
        },
        "mcp": {
          "enabled": false,
          "description": "Register Debug Adapter Protocol tracker to observe DAP messages, capabilities, and events",
          "timeout": 30000,
          "relationships": {
            "requires": [
              "debug.start"
            ],
            "recommended": [],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_NO_SESSION",
                "summary": "No active debug session",
                "is_retryable": false,
                "user_fix_hint": "Call debug.start first to create debug session"
              }
            ]
          },
          "safety": {
            "idempotent": true,
            "read_only": true,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Debugging DAP protocol issues or investigating adapter behavior\n- Capturing raw DAP message flow for analysis\n- Understanding debugger capabilities and feature support\n- Diagnosing breakpoint mapping or source location problems\n\nDON'T USE FOR:\n- Normal variable inspection (use debug.list-variables instead)\n- Getting stack traces (use debug.stack instead)\n- Evaluating expressions (use debug.evaluate instead)\n\nPREREQUISITES:\n- Active debug session must exist (debug.start)\n- Understanding of DAP protocol helpful for interpreting output\n\nSAFETY:\n- Read-only operation (only observes messages, doesn't modify)\n- Idempotent (registering multiple times has same effect)\n",
            "parameter_hints": {}
          }
        }
      },
      "scriptRelPath": "debug/tracker.js"
    },
    "debug.wait-for-hit": {
      "metadata": {
        "alias": "debug.wait-for-hit",
        "category": "debug",
        "description": "Wait for a breakpoint to be hit",
        "dangerOnly": false,
        "params": {
          "timeoutMs": {
            "type": "number",
            "required": false,
            "default": 30000,
            "description": "Maximum time to wait in milliseconds"
          }
        },
        "response": "waitable",
        "errors": [
          "E_TIMEOUT",
          "E_NO_SESSION",
          "E_ABORTED"
        ],
        "cli": {
          "command": "vscb script run debug.wait-for-hit",
          "description": "Wait for breakpoint hit",
          "examples": [
            "vscb script run debug.wait-for-hit",
            "vscb script run debug.wait-for-hit --param timeout=60000"
          ]
        },
        "mcp": {
          "enabled": true,
          "description": "Wait for execution to hit any breakpoint (blocks until pause or timeout)",
          "timeout": 90000,
          "relationships": {
            "requires": [
              "debug.start"
            ],
            "recommended": [
              "breakpoint.set"
            ],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_TIMEOUT",
                "summary": "Timeout reached before breakpoint was hit",
                "is_retryable": true,
                "user_fix_hint": "Increase timeoutMs parameter or verify breakpoint is on executable line and will be reached"
              },
              {
                "code": "E_NO_SESSION",
                "summary": "No active debug session",
                "is_retryable": false,
                "user_fix_hint": "Call debug.start first to create debug session"
              },
              {
                "code": "E_ABORTED",
                "summary": "Wait was aborted by user or session ended",
                "is_retryable": false,
                "user_fix_hint": "Debug session was terminated, restart session and retry"
              }
            ]
          },
          "safety": {
            "idempotent": false,
            "read_only": false,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Waiting for execution to reach a breakpoint after starting/continuing\n- Synchronizing workflow after debug.start or debug.continue\n- Blocking until program pauses at specific execution point\n- Automating debug workflows that require pause before inspection\n\nDON'T USE FOR:\n- Checking if session is paused (use debug.status instead)\n- Setting breakpoints (use breakpoint.set first)\n- Inspecting variables (do after wait completes)\n\nPREREQUISITES:\n- Active debug session must exist (debug.start)\n- At least one breakpoint should be set (recommended: breakpoint.set)\n- Program execution must reach breakpoint within timeout\n\nSAFETY:\n- Not idempotent (each call waits for next breakpoint hit)\n- Not read-only (advances execution state by waiting)\n- Not destructive (normal debug operation)\n",
            "parameter_hints": {
              "timeoutMs": {
                "description": "Maximum time to wait in milliseconds (default 30000)",
                "required": false,
                "examples": [
                  "30000",
                  "60000",
                  "120000"
                ],
                "note": "Use longer timeouts for slow code paths or user interaction",
                "pitfalls": [
                  "Don't use very short timeouts (< 5000ms) for complex code",
                  "Remember timeout is per call, not total workflow time"
                ]
              }
            }
          }
        }
      },
      "scriptRelPath": "debug/wait-for-hit.js"
    },
    "diagnostic.collect": {
      "metadata": {
        "alias": "diagnostic.collect",
        "name": "Collect Diagnostics",
        "category": "diag",
        "description": "Collect system, extension, and code diagnostics",
        "dangerOnly": false,
        "params": {
          "path": {
            "type": "string",
            "required": false,
            "description": "File path for file-specific diagnostics (omit for workspace-wide)"
          }
        },
        "response": "query",
        "result": {
          "diagnostics": {
            "type": "array",
            "description": "List of code diagnostics",
            "items": {
              "file": {
                "type": "string",
                "description": "File path"
              },
              "line": {
                "type": "number",
                "description": "Line number (1-indexed)"
              },
              "column": {
                "type": "number",
                "description": "Column number"
              },
              "message": {
                "type": "string",
                "description": "Diagnostic message"
              },
              "severity": {
                "type": "string",
                "description": "Severity level (error, warning, info, hint)"
              },
              "code": {
                "type": "string",
                "description": "Diagnostic code"
              },
              "source": {
                "type": "string",
                "description": "Source of diagnostic"
              }
            }
          },
          "system": {
            "type": "object",
            "description": "System information",
            "properties": {
              "vscodeVersion": {
                "type": "string"
              },
              "extensionVersion": {
                "type": "string"
              },
              "platform": {
                "type": "string"
              },
              "arch": {
                "type": "string"
              },
              "nodeVersion": {
                "type": "string"
              },
              "mode": {
                "type": "string"
              }
            }
          },
          "debug": {
            "type": "object",
            "description": "Debug session information",
            "properties": {
              "hasActiveSession": {
                "type": "boolean"
              },
              "sessionId": {
                "type": "string"
              },
              "sessionName": {
                "type": "string"
              },
              "sessionType": {
                "type": "string"
              },
              "breakpointCount": {
                "type": "number"
              }
            }
          },
          "timestamp": {
            "type": "string",
            "description": "ISO timestamp of collection"
          }
        },
        "errors": [],
        "cli": {
          "command": "diag collect",
          "description": "Collect diagnostics",
          "examples": [
            "vscb script run diagnostic.collect",
            "vscb script run diagnostic.collect --param path=/home/user/test.js"
          ]
        },
        "mcp": {
          "enabled": true,
          "description": "Gather comprehensive diagnostics including system info, debug state, and code issues",
          "timeout": 30000,
          "relationships": {
            "requires": [],
            "recommended": [],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": []
          },
          "safety": {
            "idempotent": true,
            "read_only": true,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Collecting system information for troubleshooting\n- Gathering code diagnostics (errors, warnings) from language servers\n- Inspecting debug session state and configuration\n- Creating diagnostic snapshots before reporting issues\n\nDON'T USE FOR:\n- Modifying diagnostics or fixing issues (this is read-only)\n- Running linters or formatters (this queries existing diagnostics)\n- Collecting runtime logs (use dap.logs for debug protocol logs)\n\nPREREQUISITES:\n- None (always available)\n\nSAFETY:\n- Read-only operation (no state changes)\n- Idempotent (safe to retry on timeout)\n",
            "parameter_hints": {
              "path": {
                "description": "Optional file path to filter diagnostics for a specific file",
                "required": false,
                "examples": [
                  "/Users/name/project/src/main.py",
                  "/home/user/workspace/lib/auth.js",
                  "C:\\Users\\name\\project\\api\\handler.ts"
                ],
                "note": "Omit to collect workspace-wide diagnostics from all files",
                "pitfalls": [
                  "Don't expect real-time diagnostics - this queries current cached state"
                ]
              }
            }
          }
        }
      },
      "scriptRelPath": "diag/collect.js"
    },
    "editor.get-context": {
      "metadata": {
        "alias": "editor.get-context",
        "name": "Get Editor Context",
        "category": "editor",
        "description": "Get current editor context (file path, cursor position, selection, visible range)",
        "dangerOnly": false,
        "params": {},
        "response": "query",
        "result": {
          "message": {
            "type": "string",
            "description": "Success message"
          },
          "contextAvailable": {
            "type": "boolean",
            "description": "Whether an active editor is available"
          },
          "file": {
            "type": "string",
            "description": "Active file path (null if no editor)"
          },
          "line": {
            "type": "number",
            "description": "Current cursor line (1-indexed, null if no editor)"
          }
        },
        "errors": [],
        "cli": {
          "command": "editor get-context",
          "description": "Get current editor context",
          "examples": [
            "vscb script run editor.get-context"
          ]
        },
        "mcp": {
          "enabled": true,
          "description": "Get current editor context (file, cursor position, selection, visible range)",
          "timeout": 5000,
          "relationships": {
            "requires": [],
            "recommended": [],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": []
          },
          "safety": {
            "idempotent": true,
            "read_only": true,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Getting current file path and cursor position\n- Understanding what code the user is looking at\n- Capturing context before performing operations\n- Verifying active editor state\n\nDON'T USE FOR:\n- Getting file contents (use read file tools)\n- Getting workspace information (use workspace tools)\n- Getting project structure (use symbol search)\n\nPREREQUISITES:\n- None (works even if no editor is active)\n\nPATTERNS:\n- Simple context capture: no parameters needed\n- Returns summary in data field + full context in editorContext envelope field\n- Check contextAvailable field to see if editor is active\n",
            "parameter_hints": {}
          }
        }
      },
      "scriptRelPath": "editor/get-context.js"
    },
    "editor.goto-line": {
      "metadata": {
        "alias": "editor.goto-line",
        "name": "Goto Line",
        "category": "editor",
        "description": "Open a file in the editor and navigate to a specific line and column",
        "dangerOnly": false,
        "params": {
          "path": {
            "type": "string",
            "description": "Absolute path to the file to open",
            "required": true
          },
          "line": {
            "type": "number",
            "description": "Line number to navigate to (1-indexed)",
            "required": true
          },
          "column": {
            "type": "number",
            "description": "Column number to navigate to (1-indexed, defaults to 1)",
            "required": false,
            "default": 1
          }
        },
        "response": "action",
        "errors": [
          "FILE_NOT_FOUND",
          "INVALID_POSITION",
          "NAVIGATION_FAILED"
        ],
        "cli": {
          "command": "editor goto-line",
          "description": "Navigate to a specific line in a file",
          "examples": [
            "vscb script run editor.goto-line --param path=/path/to/file.js --param line=42",
            "vscb script run editor.goto-line --param path=/path/to/file.js --param line=42 --param column=10"
          ]
        },
        "mcp": {
          "enabled": true,
          "description": "Opens a file in the VS Code editor and navigates to a specific line and column position.\nThe target line is automatically centered in the viewport for optimal visibility.\nOpens files as permanent tabs (not preview tabs).\n",
          "timeout": 10000,
          "relationships": {
            "requires": [],
            "recommended": [],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": [
              {
                "code": "FILE_NOT_FOUND",
                "summary": "The specified file does not exist or cannot be read",
                "is_retryable": false,
                "user_fix_hint": "Verify the file path is correct and the file exists"
              },
              {
                "code": "INVALID_POSITION",
                "summary": "The specified line or column is out of range",
                "is_retryable": false,
                "user_fix_hint": "Check that line/column numbers are valid for the file"
              },
              {
                "code": "NAVIGATION_FAILED",
                "summary": "Failed to open or navigate to the file",
                "is_retryable": true,
                "user_fix_hint": "Check VS Code logs for detailed error information"
              }
            ]
          },
          "safety": {
            "idempotent": true,
            "read_only": true,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Navigating to a specific location in a file (e.g., error location, reference location)\n- Opening files at specific lines from code analysis or search results\n- Jumping to code locations mentioned in logs or test output\n- Programmatically opening files with cursor positioning\n\nDON'T USE FOR:\n- Just opening a file without specific line navigation (use VS Code open command)\n- Setting breakpoints (use breakpoint.set instead)\n- Selecting ranges of text (this sets cursor position only)\n- Opening files that don't exist (will fail with FILE_NOT_FOUND)\n\nPREREQUISITES:\n- File must exist and be readable\n- Path must be absolute (not relative)\n- Line/column numbers must be within valid range for the file\n\nSAFETY:\n- Read-only operation (doesn't modify files)\n- Idempotent (can be called multiple times safely)\n- Opens permanent tabs (not preview tabs)\n",
            "parameter_hints": {
              "path": "Must be an absolute path (e.g., /workspaces/project/src/file.js, not src/file.js)",
              "line": "Line numbers are 1-indexed (first line is 1, not 0)",
              "column": "Column numbers are 1-indexed (first column is 1, not 0). Defaults to 1 if not specified."
            }
          }
        }
      },
      "scriptRelPath": "editor/goto-line.js"
    },
    "editor.show-testing-ui": {
      "metadata": {
        "alias": "editor.show-testing-ui",
        "name": "Show Testing UI",
        "category": "editor",
        "description": "Show the Testing view to trigger test discovery (enables Python test discovery)",
        "dangerOnly": false,
        "params": {},
        "response": "action",
        "errors": [],
        "cli": {
          "command": "editor show-testing-ui",
          "description": "Show Testing view to trigger test discovery",
          "examples": [
            "vscb script run editor.show-testing-ui"
          ]
        },
        "mcp": {
          "enabled": true,
          "description": "Open the VS Code Testing view to trigger automatic test discovery",
          "timeout": 60000,
          "relationships": {
            "requires": [],
            "recommended": [],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": []
          },
          "safety": {
            "idempotent": false,
            "read_only": false,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Triggering test discovery by opening the Testing UI\n- Forcing VS Code to scan workspace for tests\n- Enabling test functionality that requires the Testing view to be visible\n\nDON'T USE FOR:\n- Running or debugging tests (use tests.debug-single or debug.start)\n- Listing tests via API (this is a UI trigger, not a query)\n- Continuous test watching (this is a one-time UI open)\n\nPREREQUISITES:\n- Test framework configured in workspace (pytest, Jest, etc.)\n- Test extensions installed and enabled\n\nSAFETY:\n- Non-idempotent (opening UI multiple times may have side effects)\n- Triggers test discovery which scans filesystem\n",
            "parameter_hints": {}
          }
        }
      },
      "scriptRelPath": "editor/show-testing-ui.js"
    },
    "search.symbol-search": {
      "metadata": {
        "alias": "search.symbol-search",
        "name": "Symbol Search",
        "category": "search",
        "description": "Search symbols in workspace or get document outline (classes, functions, methods, etc.)",
        "dangerOnly": false,
        "params": {
          "query": {
            "type": "string",
            "required": false,
            "default": "",
            "description": "Search query string for workspace symbols (fuzzy matching, empty returns all)"
          },
          "mode": {
            "type": "string",
            "required": false,
            "default": "workspace",
            "description": "Search mode - \"workspace\" for global search or \"document\" for single file outline"
          },
          "path": {
            "type": "string",
            "required": false,
            "description": "File path for document mode (required when mode=document)",
            "resolve": "cwd-relative"
          },
          "kinds": {
            "type": "string",
            "required": false,
            "description": "Comma-separated symbol kinds to filter (Class, Interface, Function, Method, etc.)"
          },
          "limit": {
            "type": "number",
            "required": false,
            "default": 100,
            "min": 1,
            "max": 1000,
            "description": "Maximum number of symbols to return"
          },
          "includeLocation": {
            "type": "boolean",
            "required": false,
            "default": true,
            "description": "Include full location information (file path, line, character, range)"
          },
          "includeContainer": {
            "type": "boolean",
            "required": false,
            "default": true,
            "description": "Include container/parent symbol information"
          }
        },
        "response": "query",
        "result": {
          "mode": {
            "type": "string",
            "description": "Search mode used"
          },
          "query": {
            "type": "string",
            "description": "Query string used"
          },
          "filters": {
            "type": "object",
            "description": "Applied filters"
          },
          "results": {
            "type": "object",
            "description": "Result summary (total, returned, truncated)"
          },
          "statistics": {
            "type": "object",
            "description": "Symbol distribution statistics"
          },
          "symbols": {
            "type": "array",
            "description": "Array of matched symbols"
          }
        },
        "errors": [
          "E_FILE_NOT_FOUND",
          "E_INVALID_MODE"
        ],
        "cli": {
          "command": "search symbol-search",
          "description": "Search symbols in workspace or get document outline",
          "examples": [
            "vscb script run search.symbol-search --param query=\"UserService\"",
            "vscb script run search.symbol-search --param query=\"\" --param kinds=\"Class\"",
            "vscb script run search.symbol-search --param mode=\"document\" --param path=\"src/main.ts\"",
            "vscb script run search.symbol-search --param query=\"test\" --param kinds=\"Function,Method\" --param limit=50"
          ]
        },
        "mcp": {
          "enabled": true,
          "description": "Workspace-wide symbol search (classes, functions, methods) with optional document outline mode",
          "timeout": 10000,
          "relationships": {
            "requires": [],
            "recommended": [],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_FILE_NOT_FOUND",
                "summary": "File not found for document mode",
                "is_retryable": false,
                "user_fix_hint": "Verify file path exists in workspace"
              },
              {
                "code": "E_INVALID_MODE",
                "summary": "Invalid mode parameter",
                "is_retryable": false,
                "user_fix_hint": "Use 'workspace' or 'document'"
              }
            ]
          },
          "safety": {
            "idempotent": true,
            "read_only": true,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Finding classes, functions, methods by name across workspace\n- Getting file outline/structure (document mode)\n- Discovering available symbols in codebase\n- Navigating to symbol definitions\n- Markdown document outline (headers as symbols)\n\nDON'T USE FOR:\n- Text/regex search (use workspace text search instead)\n- Finding symbol references (use find-references if available)\n- Searching file contents (symbols are declarations only)\n\nPREREQUISITES:\n- None for workspace mode (always works)\n- File must exist for document mode\n\nPATTERNS:\n- Find all classes: query=\"\", kinds=\"Class\"\n- Search by name: query=\"UserService\"\n- File structure: mode=\"document\", path=\"src/file.ts\"\n- Multiple kinds: kinds=\"Class,Interface,Function\"\n- Minimal output: includeLocation=false, includeContainer=false\n",
            "parameter_hints": {
              "query": {
                "description": "Fuzzy search string (empty returns all symbols, respects kind filter)",
                "required": false,
                "examples": [
                  "UserService",
                  "Auth",
                  ""
                ],
                "note": "Uses VS Code's built-in fuzzy matching, case-insensitive"
              },
              "mode": {
                "description": "Search scope - workspace (global) or document (single file)",
                "required": false,
                "examples": [
                  "workspace",
                  "document"
                ],
                "note": "Document mode requires path parameter, returns hierarchical structure flattened"
              },
              "path": {
                "description": "Absolute or workspace-relative file path for document mode",
                "required": false,
                "examples": [
                  "src/services/UserService.ts",
                  "/absolute/path/to/file.py",
                  "README.md"
                ],
                "note": "Required when mode=document, works with code and Markdown files"
              },
              "kinds": {
                "description": "Filter by symbol types (comma-separated)",
                "required": false,
                "examples": [
                  "Class",
                  "Class,Interface",
                  "Function,Method",
                  "String"
                ],
                "note": "Available kinds: File, Module, Namespace, Package, Class, Method, Property, Field, Constructor, Enum, Interface, Function, Variable, Constant, String (for Markdown headers), EnumMember, Struct, Event",
                "pitfalls": [
                  "Kind names are case-sensitive (use 'Class' not 'class')",
                  "Markdown headers use 'String' kind"
                ]
              },
              "limit": {
                "description": "Maximum symbols to return (prevents overwhelming output)",
                "required": false,
                "examples": [
                  "50",
                  "100",
                  "500"
                ],
                "note": "Default 100, max 1000. Check results.truncated to see if more exist"
              },
              "includeLocation": {
                "description": "Include file path, line, character, and range in output",
                "required": false,
                "examples": [
                  "true",
                  "false"
                ],
                "note": "Set to false for minimal output when only names/kinds needed"
              },
              "includeContainer": {
                "description": "Include parent symbol name (e.g., class name for methods)",
                "required": false,
                "examples": [
                  "true",
                  "false"
                ],
                "note": "Provides context for nested symbols, useful for disambiguation"
              }
            }
          }
        }
      },
      "scriptRelPath": "search/symbol-search.js"
    },
    "symbol.calls": {
      "metadata": {
        "alias": "symbol.calls",
        "name": "Call Hierarchy Navigation",
        "category": "symbol",
        "description": "Find incoming/outgoing calls using LSP Call Hierarchy (two-step process)",
        "dangerOnly": false,
        "params": {
          "nodeId": {
            "type": "string",
            "required": false,
            "description": "Flowspace ID (e.g., \"method:src/Calculator.ts:Calculator.add\")"
          },
          "path": {
            "type": "string",
            "required": false,
            "description": "File path (required with symbol parameter, alternative to nodeId)",
            "resolve": "cwd-relative"
          },
          "symbol": {
            "type": "string",
            "required": false,
            "description": "Symbol name (e.g., \"Calculator.add\", required with path parameter)"
          },
          "direction": {
            "type": "string",
            "required": false,
            "default": "incoming",
            "description": "Call direction - \"incoming\" (callers) or \"outgoing\" (callees)",
            "values": [
              "incoming",
              "outgoing"
            ]
          },
          "enrichWithFlowspaceIds": {
            "type": "boolean",
            "required": false,
            "default": false,
            "description": "Add Flowspace IDs to each call result (slower, requires symbol resolution)"
          }
        },
        "response": "query",
        "result": {
          "direction": {
            "type": "string",
            "description": "Direction queried (incoming or outgoing)"
          },
          "calls": {
            "type": "array",
            "description": "Array of call hierarchy items"
          },
          "total": {
            "type": "number",
            "description": "Total number of calls found"
          },
          "targetSymbol": {
            "type": "object",
            "description": "Target symbol that was resolved"
          },
          "prepareSuccess": {
            "type": "boolean",
            "description": "Whether prepareCallHierarchy succeeded"
          },
          "message": {
            "type": "string",
            "description": "Additional context message (optional)"
          }
        },
        "errors": [
          "E_NOT_FOUND",
          "E_NO_LANGUAGE_SERVER",
          "E_TIMEOUT",
          "E_INVALID_INPUT",
          "E_AMBIGUOUS_SYMBOL"
        ],
        "cli": {
          "command": "symbol calls",
          "description": "Find incoming or outgoing calls using Call Hierarchy",
          "examples": [
            "vscb script run symbol.calls --param nodeId=\"method:src/Calculator.ts:Calculator.add\" --param direction=\"incoming\"",
            "vscb script run symbol.calls --param path=\"src/UserService.ts\" --param symbol=\"UserService.getUser\" --param direction=\"outgoing\"",
            "vscb script run symbol.calls --param nodeId=\"function:lib/utils.py:format_date\" --param enrichWithFlowspaceIds=true"
          ]
        },
        "llm": {
          "when_to_use": "USE FOR:\n- Finding all callers of a function/method (incoming direction)\n- Finding all callees from a function/method (outgoing direction)\n- Understanding call relationships in code navigation\n- Discovering usage patterns across codebase\n- Identifying refactoring impact (who calls this method?)\n\nDON'T USE FOR:\n- Finding all references (use symbol.navigate action=references instead)\n- Simple text search (use search tools instead)\n- Languages without LSP Call Hierarchy support (C# OmniSharp)\n\nPREREQUISITES:\n- Language server must support Call Hierarchy (LSP 3.16+)\n- Symbol must exist and be indexable by language server\n- File must be part of workspace (not external dependencies)\n\nPATTERNS:\n- **Two-step LSP process**: prepareCallHierarchy → provide{Incoming|Outgoing}Calls\n- **Position-sensitive**: Uses DocumentSymbol.selectionRange.start (identifier token)\n- **Empty results OK**: Returns empty array if symbol has no calls (not an error)\n\nSUPPORTED LANGUAGES:\n- ✅ TypeScript/JavaScript (built-in TS server)\n- ✅ Python (Pylance)\n- ✅ Java (JDT LS)\n- ✅ Dart (Dart Analysis Server)\n- ✅ Go (gopls - with lambda caveats)\n- ❌ C# (OmniSharp - not supported; C# Dev Kit status unclear)\n",
          "parameter_hints": {
            "nodeId": {
              "description": "Flowspace ID to identify the symbol",
              "examples": [
                "method:src/Calculator.ts:Calculator.add",
                "function:lib/utils.py:format_date",
                "method:com/example/UserService.java:UserService.getUser"
              ],
              "notes": [
                "Must use forward slashes for Windows paths (C:/Users/ not C:\\Users\\)",
                "Alternative to path+symbol parameters (mutually exclusive)"
              ],
              "pitfalls": [
                "Incorrect path separators will cause parse errors",
                "Symbol must exist at exact location specified"
              ]
            },
            "path": {
              "description": "Absolute file path (used with symbol parameter)",
              "examples": [
                "/workspaces/project/src/Calculator.ts",
                "C:/Users/dev/project/lib/utils.py"
              ],
              "notes": [
                "Must be absolute path, not relative",
                "Used together with symbol parameter",
                "Alternative to nodeId parameter (mutually exclusive)"
              ],
              "pitfalls": [
                "Relative paths will fail to resolve",
                "File must exist and be part of workspace"
              ]
            },
            "symbol": {
              "description": "Symbol name to find (used with path parameter)",
              "examples": [
                "Calculator.add (method in class)",
                "format_date (top-level function)",
                "UserService.getUser (Java method)"
              ],
              "notes": [
                "Use qualified name for class methods (ClassName.methodName)",
                "Must match exact symbol name in code",
                "Case-sensitive matching"
              ],
              "pitfalls": [
                "Ambiguous names (multiple matches) will cause errors",
                "Missing class qualifier for methods will fail"
              ]
            },
            "direction": {
              "description": "Call direction to query",
              "examples": [
                "incoming (find callers - who calls this symbol?)",
                "outgoing (find callees - what does this symbol call?)"
              ],
              "notes": [
                "Default is \"incoming\" if omitted",
                "Determines which LSP command is used (provideIncomingCalls vs provideOutgoingCalls)"
              ],
              "pitfalls": [
                "Invalid values (not \"incoming\" or \"outgoing\") cause E_INVALID_INPUT",
                "Empty results mean no calls in that direction (not an error)"
              ]
            },
            "enrichWithFlowspaceIds": {
              "description": "Add Flowspace IDs to call results (slower, optional)",
              "examples": [
                "true (include nodeId for each caller/callee)",
                "false (omit nodeId, faster response)"
              ],
              "notes": [
                "Default is false for performance",
                "Adds nodeId field to each call result",
                "Useful when chaining navigation operations"
              ],
              "pitfalls": [
                "Significantly slower for large call graphs",
                "May fail silently if symbol provider unavailable"
              ]
            }
          },
          "error_contract": {
            "E_NOT_FOUND": {
              "description": "Symbol not found at specified location",
              "fix_hints": [
                "Verify symbol name matches code exactly (case-sensitive)",
                "Check file exists and is part of workspace",
                "Ensure language server has indexed the file",
                "For Flowspace IDs, verify path separators (forward slashes)"
              ]
            },
            "E_NO_LANGUAGE_SERVER": {
              "description": "Language server doesn't support Call Hierarchy or isn't ready",
              "fix_hints": [
                "Check language is supported (TypeScript, Python, Java, Dart, Go)",
                "C# OmniSharp does not support Call Hierarchy - use symbol.navigate instead",
                "Wait for language server to finish indexing (first workspace load)",
                "Ensure document symbols are available (prepareCallHierarchy requires them)",
                "Some languages have limited support (JavaScript call hierarchy is partial)"
              ]
            },
            "E_TIMEOUT": {
              "description": "LSP operation exceeded 10s timeout",
              "fix_hints": [
                "Large codebases may take longer to analyze",
                "Wait for language server warm-up and retry",
                "Check VS Code isn't under heavy load",
                "May indicate language server issue - restart extension host"
              ]
            },
            "E_INVALID_INPUT": {
              "description": "Invalid parameter values",
              "fix_hints": [
                "direction must be \"incoming\" or \"outgoing\"",
                "Must provide either nodeId OR (path + symbol), not both",
                "path must be absolute, not relative"
              ]
            },
            "E_AMBIGUOUS_SYMBOL": {
              "description": "Multiple symbols match the name (from symbol-resolver)",
              "fix_hints": [
                "Use more specific qualified name (ClassName.methodName)",
                "Provide Flowspace ID instead of symbol name for precision",
                "Check for duplicate symbol definitions in file"
              ]
            }
          }
        },
        "mcp": {
          "display_name": "Find Calls (Call Hierarchy)",
          "tool_name": "symbol_calls",
          "read_only": true,
          "idempotent": true,
          "relationships": {
            "requires": [
              "Phase 1 symbol-resolver (resolveSymbolInput, getLSPResultWithTimeout)",
              "VS Code LSP providers (prepareCallHierarchy, provide{Incoming|Outgoing}Calls)"
            ],
            "related": [
              "symbol.navigate (for references instead of calls)",
              "search.symbol-search (for finding symbols by name)"
            ]
          },
          "safety": {
            "side_effects": "none",
            "data_access": "read-only (workspace files via LSP)",
            "performance": "fast (10s timeout per LSP operation)"
          }
        }
      },
      "scriptRelPath": "symbol/calls.js"
    },
    "symbol.navigate": {
      "metadata": {
        "alias": "symbol.navigate",
        "name": "Symbol Navigation",
        "category": "symbol",
        "description": "Find references or implementations for symbols using Flowspace IDs or symbol names",
        "dangerOnly": false,
        "params": {
          "nodeId": {
            "type": "string",
            "required": false,
            "description": "Flowspace ID (e.g., \"method:src/Calculator.ts:Calculator.add\")"
          },
          "path": {
            "type": "string",
            "required": false,
            "description": "File path (required with symbol parameter, alternative to nodeId)",
            "resolve": "cwd-relative"
          },
          "symbol": {
            "type": "string",
            "required": false,
            "description": "Symbol name (e.g., \"Calculator.add\", required with path parameter)"
          },
          "action": {
            "type": "string",
            "required": false,
            "default": "references",
            "description": "Navigation action - \"references\" or \"implementations\""
          },
          "includeDeclaration": {
            "type": "boolean",
            "required": false,
            "description": "Include declaration in references results (undefined uses provider default)"
          },
          "enrichWithFlowspaceIds": {
            "type": "boolean",
            "required": false,
            "default": false,
            "description": "Add Flowspace IDs to each location (slower, requires symbol resolution)"
          }
        },
        "response": "query",
        "result": {
          "action": {
            "type": "string",
            "description": "Action performed (references or implementations)"
          },
          "input": {
            "type": "object",
            "description": "Input used (type and value)"
          },
          "locations": {
            "type": "array",
            "description": "Array of location results"
          },
          "total": {
            "type": "number",
            "description": "Total number of locations found"
          },
          "timeout": {
            "type": "boolean",
            "description": "True if LSP provider timed out (optional field)"
          },
          "message": {
            "type": "string",
            "description": "Additional context message (optional field)"
          }
        },
        "errors": [
          "E_NOT_FOUND",
          "E_AMBIGUOUS_SYMBOL",
          "E_INVALID_INPUT",
          "E_NO_LANGUAGE_SERVER"
        ],
        "cli": {
          "command": "symbol navigate",
          "description": "Find references or implementations for a symbol",
          "examples": [
            "vscb script run symbol.navigate --param nodeId=\"method:src/Calculator.ts:Calculator.add\" --param action=\"references\"",
            "vscb script run symbol.navigate --param path=\"src/Calculator.ts\" --param symbol=\"Calculator.add\" --param action=\"implementations\"",
            "vscb script run symbol.navigate --param nodeId=\"function:src/utils.js:formatDate\" --param action=\"references\" --param includeDeclaration=false",
            "vscb script run symbol.navigate --param path=\"src/UserService.ts\" --param symbol=\"UserService.findUser\" --param enrichWithFlowspaceIds=true"
          ]
        },
        "mcp": {
          "enabled": true,
          "description": "Find references or implementations for symbols using semantic identifiers (Flowspace IDs or symbol names)",
          "timeout": 15000,
          "relationships": {
            "requires": [],
            "recommended": [
              "search.symbol-search"
            ],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_NOT_FOUND",
                "summary": "Symbol not found at specified location",
                "is_retryable": false,
                "user_fix_hint": "Verify symbol name/Flowspace ID is correct and symbol exists in file"
              },
              {
                "code": "E_AMBIGUOUS_SYMBOL",
                "summary": "Multiple symbols match the given name",
                "is_retryable": true,
                "user_fix_hint": "Use more specific qualified name (e.g., 'ClassName.methodName' instead of 'methodName')"
              },
              {
                "code": "E_INVALID_INPUT",
                "summary": "Must provide either nodeId OR both path and symbol",
                "is_retryable": true,
                "user_fix_hint": "Check parameter combination - use nodeId alone OR path+symbol together"
              },
              {
                "code": "E_NO_LANGUAGE_SERVER",
                "summary": "No language server available for this file type",
                "is_retryable": false,
                "user_fix_hint": "Install appropriate language extension (Python: Pylance, Java: Java Language Support, etc.)"
              }
            ]
          },
          "safety": {
            "idempotent": true,
            "read_only": true,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Finding all references to a function, method, class, or variable\n- Discovering implementations of an interface or abstract class\n- Semantic code navigation using Flowspace IDs (position-independent)\n- Cross-file dependency analysis\n- Refactoring planning (understanding impact of changes)\n- Navigating from symbol name without knowing cursor position\n\nDON'T USE FOR:\n- Text search (use workspace text search)\n- Symbol definitions (use search.symbol-search with document mode)\n- Finding callers/callees (use hierarchy.calls if available)\n- Renaming symbols (use symbol.rename)\n\nPREREQUISITES:\n- File must exist and be indexed by VS Code\n- Symbol must exist at specified location\n- Language server must support references/implementations (TypeScript, Python, Java, C#, Go, Rust)\n- For Flowspace IDs: Use forward slashes in paths (C:/Users/ not C:\\Users\\)\n\nSAFETY:\n- Read-only operation (no file modifications)\n- Idempotent (safe to call multiple times)\n- First call may be slow (3-10s) if workspace not indexed yet\n\nPERFORMANCE NOTES:\n- First workspace call: 3-10s (cold start indexing)\n- Subsequent calls: <1s (cached index)\n- enrichWithFlowspaceIds=true adds ~50-200ms per location\n- Timeout protection: 15s max (returns partial results)\n",
            "parameter_hints": {
              "nodeId": {
                "description": "Flowspace ID for semantic, position-independent navigation",
                "required": false,
                "examples": [
                  "method:src/Calculator.ts:Calculator.add",
                  "function:src/utils.js:formatDate",
                  "class:src/models/User.py:User"
                ],
                "note": "Preferred for automation - no cursor position needed, works across file moves",
                "pitfalls": [
                  "Use forward slashes in Windows paths (C:/Users/ not C:\\Users\\)",
                  "Qualified names must match exact symbol hierarchy"
                ]
              },
              "path": {
                "description": "File path for symbol name lookup (alternative to nodeId)",
                "required": false,
                "examples": [
                  "src/Calculator.ts",
                  "src/services/UserService.py",
                  "/absolute/path/to/file.js"
                ],
                "note": "Required when using symbol parameter, ignored when nodeId provided"
              },
              "symbol": {
                "description": "Symbol qualified name within file (alternative to nodeId)",
                "required": false,
                "examples": [
                  "Calculator.add",
                  "UserService.findUser",
                  "formatDate"
                ],
                "note": "Required when using path parameter, supports hierarchical names (Class.method)",
                "pitfalls": [
                  "Must be qualified for nested symbols (use 'Outer.Inner.method' not just 'method')",
                  "Case-sensitive matching"
                ]
              },
              "action": {
                "description": "Type of navigation to perform",
                "required": false,
                "examples": [
                  "references",
                  "implementations"
                ],
                "note": "Default is 'references'. Use 'implementations' for interfaces/abstract classes",
                "language_specific": {
                  "typescript": "Both actions supported (interfaces, abstract classes)",
                  "python": "References supported; implementations limited (Python is dynamic)",
                  "java": "Both actions fully supported",
                  "javascript": "References supported; implementations not applicable (no interfaces)"
                }
              },
              "includeDeclaration": {
                "description": "Whether to include symbol declaration in references results (tri-state)",
                "required": false,
                "examples": [
                  "true",
                  "false",
                  "undefined"
                ],
                "note": "undefined (omit parameter) uses language server default; explicit true/false overrides",
                "pitfalls": [
                  "Only affects 'references' action, ignored for 'implementations'",
                  "Behavior differs by language server (some always include, some never)"
                ]
              },
              "enrichWithFlowspaceIds": {
                "description": "Add Flowspace IDs to each location in results",
                "required": false,
                "examples": [
                  "true",
                  "false"
                ],
                "note": "Default false for performance. Enable when you need semantic IDs for automation",
                "performance_impact": "Adds 50-200ms per location (requires symbol resolution)"
              }
            }
          }
        }
      },
      "scriptRelPath": "symbol/navigate.js"
    },
    "symbol.rename": {
      "metadata": {
        "alias": "symbol.rename",
        "name": "Symbol Rename",
        "category": "symbol",
        "description": "Rename symbols (variables, functions, classes, methods) workspace-wide using LSP. Updates all references and imports atomically.",
        "dangerOnly": false,
        "params": {
          "nodeId": {
            "type": "string",
            "required": false,
            "description": "Flowspace ID (e.g., \"method:src/Calculator.ts:Calculator.add\")"
          },
          "path": {
            "type": "string",
            "required": false,
            "description": "File path (required with symbol parameter, alternative to nodeId)",
            "resolve": "cwd-relative"
          },
          "symbol": {
            "type": "string",
            "required": false,
            "description": "Symbol name (e.g., \"Calculator.add\", required with path parameter)"
          },
          "newName": {
            "type": "string",
            "required": true,
            "description": "New name for the symbol (must be non-empty, language-specific naming rules apply)"
          }
        },
        "response": "action",
        "result": {
          "success": {
            "type": "boolean",
            "description": "True if rename applied successfully"
          },
          "details": {
            "type": "object",
            "description": "Rename operation details",
            "properties": {
              "applied": {
                "type": "boolean",
                "description": "True if WorkspaceEdit was applied"
              },
              "changes": {
                "type": "array",
                "description": "Files modified with edit counts"
              },
              "totalFiles": {
                "type": "number",
                "description": "Total number of files modified"
              },
              "totalEdits": {
                "type": "number",
                "description": "Total number of text edits applied"
              },
              "input": {
                "type": "object",
                "description": "Input parameters used"
              }
            }
          }
        },
        "errors": [
          "E_NOT_FOUND",
          "E_AMBIGUOUS_SYMBOL",
          "E_INVALID_INPUT",
          "E_NO_LANGUAGE_SERVER",
          "E_FILE_READ_ONLY",
          "E_OPERATION_FAILED",
          "E_TIMEOUT"
        ],
        "cli": {
          "command": "symbol rename",
          "description": "Rename a symbol workspace-wide with automatic reference updates",
          "examples": [
            "vscb script run symbol.rename --param nodeId=\"method:src/Calculator.ts:Calculator.add\" --param newName=\"addNumbers\"",
            "vscb script run symbol.rename --param path=\"src/Calculator.ts\" --param symbol=\"Calculator.add\" --param newName=\"sum\"",
            "vscb script run symbol.rename --param nodeId=\"class:src/User.ts:User\" --param newName=\"UserModel\""
          ]
        },
        "mcp": {
          "enabled": true,
          "description": "Rename symbols (variables, functions, classes, methods) workspace-wide using LSP. Updates all references and imports atomically.",
          "timeout": 15000,
          "relationships": {
            "requires": [],
            "recommended": [
              {
                "tool": "search.symbol-search",
                "note": "Find symbols before renaming"
              },
              {
                "tool": "symbol.navigate",
                "note": "⚠️ Different response format: navigate returns direct data {action, locations}, rename returns ActionScript envelope {success, data}"
              }
            ],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_NOT_FOUND",
                "summary": "Symbol not found at specified location",
                "is_retryable": false,
                "user_fix_hint": "Verify symbol name/Flowspace ID is correct and symbol exists in file"
              },
              {
                "code": "E_AMBIGUOUS_SYMBOL",
                "summary": "Multiple symbols match the given name",
                "is_retryable": true,
                "user_fix_hint": "Use more specific qualified name (e.g., 'ClassName.methodName' instead of 'methodName')"
              },
              {
                "code": "E_INVALID_INPUT",
                "summary": "Invalid parameters: must provide either nodeId OR both path and symbol, and newName must be non-empty",
                "is_retryable": true,
                "user_fix_hint": "Check parameter combination - use nodeId alone OR path+symbol together, ensure newName is non-empty string"
              },
              {
                "code": "E_NO_LANGUAGE_SERVER",
                "summary": "No language server available for this file type",
                "is_retryable": false,
                "user_fix_hint": "Install appropriate language extension (Python: Pylance, Java: Java Language Support, etc.)"
              },
              {
                "code": "E_FILE_READ_ONLY",
                "summary": "One or more files are read-only or permission denied",
                "is_retryable": false,
                "user_fix_hint": "Check file permissions using chmod/attrib; ensure files are not locked by another application"
              },
              {
                "code": "E_OPERATION_FAILED",
                "summary": "WorkspaceEdit application failed",
                "is_retryable": true,
                "user_fix_hint": "Common causes: (1) File locked by another application, (2) File modified concurrently, (3) File deleted after validation. Ensure files are saved and not open in other editors. Try again after closing other editors."
              },
              {
                "code": "E_TIMEOUT",
                "summary": "LSP rename provider timeout (10s)",
                "is_retryable": true,
                "user_fix_hint": "Try again; if persists, check language server is responding (large workspaces may be slow)"
              }
            ]
          },
          "safety": {
            "idempotent": false,
            "read_only": false,
            "destructive": true
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Renaming variables, functions, classes, methods, or type aliases safely\n- Refactoring code to use better identifier names\n- Updating symbol names across multiple files atomically\n- Changing class names and updating all imports/exports\n- Renaming interface implementations across codebase\n\nDON'T USE FOR:\n- Text-based find-and-replace (use workspace search)\n- Renaming files (use file system operations)\n- Refactoring without LSP support (manual edits safer)\n- Preview/dry-run (no preview mode - use symbol.navigate first to check references)\n\nPREREQUISITES:\n- File must exist and be indexed by VS Code\n- Symbol must exist at specified location\n- Language server must support rename (TypeScript, Python, Java, C#, Go, Rust)\n- All affected files must be writable (not read-only)\n- Files should be saved before rename\n- For Flowspace IDs: Use forward slashes in paths (C:/Users/ not C:\\Users\\)\n\nSAFETY:\n- ⚠️ DESTRUCTIVE OPERATION: Modifies files immediately (cannot undo via API)\n- Atomic guarantee: All files updated or none (WorkspaceEdit.applyEdit atomicity)\n- Pre-validation checks file permissions before applying changes\n- NOT idempotent (running twice renames to newName twice)\n- Commit changes to version control before renaming for easy rollback\n\nWORKFLOW:\n1. (Recommended) Call symbol.navigate first to preview impact\n2. (Optional) Commit current changes to git for easy rollback\n3. Call symbol.rename with new name\n4. Check result.data.changes to verify expected files modified\n5. Test the changes before committing\n\nPERFORMANCE NOTES:\n- First workspace call: 3-10s (cold start indexing)\n- Subsequent calls: <1s for single-file, 1-3s for multi-file\n- Pre-validation adds ~10-50ms (file permission checks)\n- Timeout protection: 15s max\n\nRESPONSE FORMAT:\n- This tool returns ActionScript envelope: {success: true, details: {...}} or {success: false, reason: \"...\"}\n- Unlike symbol.navigate (QueryScript), results are wrapped in success/error envelope\n- Access results via: result.details.changes (NOT result.changes directly)\n- Check operation success: result.success === true before accessing result.details\n\nCOMPARISON WITH symbol.navigate:\n- symbol.navigate returns: {action, input, locations, total} (direct data)\n- symbol.rename returns: {success, details: {applied, changes, totalFiles, totalEdits}} (wrapped)\n- Reason: navigate is read-only, rename is destructive (needs success/error semantics)\n- Both use same input format (nodeId OR path+symbol)\n",
            "parameter_hints": {
              "nodeId": {
                "description": "Flowspace ID for semantic, position-independent navigation",
                "required": false,
                "examples": [
                  "method:src/Calculator.ts:Calculator.add",
                  "function:src/utils.js:formatDate",
                  "class:src/models/User.py:User"
                ],
                "note": "Preferred for automation - no cursor position needed, works across file moves",
                "pitfalls": [
                  "Use forward slashes in Windows paths (C:/Users/ not C:\\Users\\)",
                  "Qualified names must match exact symbol hierarchy"
                ]
              },
              "path": {
                "description": "File path for symbol name lookup (alternative to nodeId)",
                "required": false,
                "examples": [
                  "src/Calculator.ts",
                  "src/services/UserService.py",
                  "/absolute/path/to/file.js"
                ],
                "note": "Required when using symbol parameter, ignored when nodeId provided"
              },
              "symbol": {
                "description": "Symbol qualified name within file (alternative to nodeId)",
                "required": false,
                "examples": [
                  "Calculator.add",
                  "UserService.findUser",
                  "formatDate"
                ],
                "note": "Required when using path parameter, supports hierarchical names (Class.method)",
                "pitfalls": [
                  "Must be qualified for nested symbols (use 'Outer.Inner.method' not just 'method')",
                  "Case-sensitive matching"
                ]
              },
              "newName": {
                "description": "New name for the symbol (language-specific naming rules apply)",
                "required": true,
                "examples": [
                  "addNumbers",
                  "UserModel",
                  "calculateTotal"
                ],
                "note": "Must be non-empty; LSP provider may validate naming conventions",
                "language_specific": {
                  "typescript": "camelCase for variables/functions, PascalCase for classes/interfaces",
                  "python": "snake_case for functions/variables, PascalCase for classes",
                  "java": "camelCase for methods/variables, PascalCase for classes",
                  "javascript": "camelCase for functions/variables, PascalCase for classes; CommonJS require() may not update all imports (use ES6 modules for full rename support)"
                },
                "pitfalls": [
                  "No validation of naming conventions beyond non-empty check",
                  "Some languages have reserved keywords - LSP provider may reject",
                  "JavaScript CommonJS: require() imports may not update automatically",
                  "Python dynamic typing: runtime string references (getattr) won't be renamed"
                ]
              }
            }
          }
        }
      },
      "scriptRelPath": "symbol/rename.js"
    },
    "test.debug-single": {
      "metadata": {
        "alias": "test.debug-single",
        "name": "Debug Single Test",
        "category": "tests",
        "description": "Debug a single test at specified file location using VS Code Testing API",
        "dangerOnly": false,
        "params": {
          "path": {
            "type": "string",
            "required": true,
            "description": "Absolute path to the test file"
          },
          "line": {
            "type": "number",
            "required": true,
            "description": "Line number where the test is located (1-indexed)"
          },
          "column": {
            "type": "number",
            "required": false,
            "default": 1,
            "description": "Column position (1-indexed, defaults to 1)"
          },
          "timeoutMs": {
            "type": "number",
            "required": false,
            "default": 30000,
            "description": "Maximum time to wait for debug session to start (in milliseconds)"
          }
        },
        "response": "waitable",
        "errors": [
          "E_TIMEOUT",
          "E_NO_TEST_AT_CURSOR",
          "E_API_UNAVAILABLE",
          "E_DISCOVERY_FAILED",
          "E_FILE_NOT_FOUND"
        ],
        "cli": {
          "command": "tests debug-single",
          "description": "Debug a single test at specific location",
          "examples": [
            "vscb script run test.debug-single --param path=\"/path/to/test.py\" --param line=25",
            "vscb script run test.debug-single --param path=\"/path/to/test.js\" --param line=10 --param column=5"
          ]
        },
        "mcp": {
          "enabled": true,
          "description": "Start a debug session for a single test at a specific file location, combining test discovery and debugging",
          "timeout": 60000,
          "relationships": {
            "requires": [],
            "recommended": [],
            "provides": [
              "debugSessionId"
            ],
            "conflicts": [
              "debug.start"
            ]
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_FILE_NOT_FOUND",
                "summary": "Test file does not exist at specified path",
                "is_retryable": false,
                "user_fix_hint": "Verify file path is absolute and file exists"
              },
              {
                "code": "E_NO_TEST_AT_CURSOR",
                "summary": "No test found at specified line/column position",
                "is_retryable": false,
                "user_fix_hint": "Check line number points to a test function/method"
              },
              {
                "code": "E_TIMEOUT",
                "summary": "Test discovery or debug session startup exceeded timeout",
                "is_retryable": true,
                "user_fix_hint": "Increase timeoutMs parameter or check test framework configuration"
              }
            ]
          },
          "safety": {
            "idempotent": false,
            "read_only": false,
            "destructive": false
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Starting a debug session for a single test at a specific file location\n- Combining test discovery and debugging in one operation\n- Debugging tests when you know the file path and line number\n\nDON'T USE FOR:\n- Debugging multiple tests (this targets a single test)\n- General code debugging (use debug.start with launch configuration)\n- Running tests without debugging (VS Code has separate test runners)\n\nPREREQUISITES:\n- Valid test file exists at specified path\n- Line number points to a test function/method\n- VS Code Testing API is available for the language\n- Test framework is configured (pytest for Python, Jest for JS, etc.)\n\nSAFETY:\n- Non-idempotent (creates new debug session each time)\n- Conflicts with debug.start (manages its own session)\n",
            "parameter_hints": {
              "path": {
                "description": "Absolute path to the test file to debug",
                "required": true,
                "examples": [
                  "/Users/name/project/test/python/test_example.py",
                  "/home/user/workspace/tests/unit/test_auth.js",
                  "C:\\Users\\name\\project\\tests\\test_api.py"
                ],
                "note": "Must be absolute path, not relative or workspace-relative",
                "pitfalls": [
                  "Don't use relative paths like './test.py' - must be absolute",
                  "Don't use non-test files - must be a file recognized by test framework"
                ]
              },
              "line": {
                "description": "Line number where the test function/method is defined (1-indexed)",
                "required": true,
                "examples": [
                  "25",
                  "10",
                  "142"
                ],
                "note": "Must point to the line containing the test function definition",
                "pitfalls": [
                  "Don't use line numbers inside the test body - must be the definition line"
                ]
              },
              "column": {
                "description": "Column position for precise test location (1-indexed)",
                "required": false,
                "examples": [
                  "1",
                  "5",
                  "8"
                ],
                "note": "Defaults to 1 if omitted; rarely needed for test discovery"
              },
              "timeoutMs": {
                "description": "Maximum time to wait for test discovery and session startup",
                "required": false,
                "examples": [
                  "30000",
                  "60000",
                  "90000"
                ],
                "note": "Increase for slow test frameworks or large projects; default is 30000ms (30 seconds)"
              }
            }
          }
        }
      },
      "scriptRelPath": "tests/debug-single.js"
    },
    "util.restart-vscode": {
      "metadata": {
        "alias": "util.restart-vscode",
        "name": "Restart VS Code",
        "category": "utils",
        "description": "Reload VS Code window to apply extension updates (useful after just install-extension)",
        "dangerOnly": false,
        "params": {},
        "response": "action",
        "errors": [
          "E_RESTART_FAILED"
        ],
        "cli": {
          "command": "utils restart-vscode",
          "description": "Reload VS Code window",
          "examples": [
            "vscb script run util.restart-vscode"
          ]
        },
        "mcp": {
          "enabled": true,
          "description": "Reload the VS Code window to apply extension updates or reset state",
          "timeout": 15000,
          "relationships": {
            "requires": [],
            "recommended": [],
            "provides": [],
            "conflicts": []
          },
          "error_contract": {
            "errors": [
              {
                "code": "E_RESTART_FAILED",
                "summary": "Failed to trigger VS Code window reload",
                "is_retryable": true,
                "user_fix_hint": "Verify VS Code API is responsive; try manual reload via Command Palette"
              }
            ]
          },
          "safety": {
            "idempotent": false,
            "read_only": false,
            "destructive": true
          },
          "llm": {
            "when_to_use": "USE FOR:\n- Applying extension updates that require window reload\n- Resetting VS Code state after configuration changes\n- Recovering from extension conflicts or errors\n- Completing workflows that modify extensions (after install/uninstall)\n\nDON'T USE FOR:\n- Normal debugging workflows (not required for debug sessions)\n- Applying settings changes (most apply without reload)\n- Routine operations (this is disruptive)\n\nPREREQUISITES:\n- User has saved all important work (unsaved changes will be lost!)\n- No critical debug session in progress\n\nSAFETY:\n- ⚠️ DESTRUCTIVE: Kills editor process, loses unsaved work\n- Non-idempotent (each reload restarts entire window)\n- This is the ONLY tool with destructive=true\n",
            "parameter_hints": {}
          }
        }
      },
      "scriptRelPath": "utils/restart-vscode.js"
    }
  }
}