#!/usr/bin/env node

/**
 * Generate Zod schemas from script metadata
 *
 * This script reads the manifest.json and generates TypeScript code
 * containing Zod schemas for runtime parameter validation.
 */

import * as fs from 'fs';
import * as path from 'path';

export interface ParamDefinition {
    type: 'string' | 'number' | 'boolean' | 'enum' | 'array' | 'object';
    required?: boolean;
    description?: string;
    default?: any;

    // String constraints
    minLength?: number;
    maxLength?: number;
    pattern?: string;    // Regex pattern for string validation

    // Number constraints
    min?: number;
    max?: number;
    integer?: boolean;

    // Enum values
    values?: string[];

    // Additional features
    aliases?: string[];  // Alternative names for this parameter
    resolve?: 'workspace-relative' | 'absolute' | 'cwd-relative';  // Path resolution strategy
    coerce?: boolean;    // Override global coercion setting for this parameter
}

export interface ScriptMetadata {
    alias: string;
    description: string;
    params?: Record<string, ParamDefinition>;
}

export interface ManifestV2 {
    version: number;
    generatedAt?: string;
    scripts: Record<string, {
        metadata: ScriptMetadata;
    }>;
}

interface GenerationOptions {
    enableCoercion?: boolean;
}

/**
 * Convert a single parameter definition to Zod schema code
 */
function paramToZodSchema(param: ParamDefinition, options: GenerationOptions = {}): string {
    let schema = '';

    switch (param.type) {
        case 'string':
            schema = 'z.string()';
            if (param.minLength !== undefined) {
                schema += `.min(${param.minLength})`;
            }
            if (param.maxLength !== undefined) {
                schema += `.max(${param.maxLength})`;
            }
            if (param.pattern) {
                // Escape the pattern string for JavaScript
                const escapedPattern = param.pattern.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
                schema += `.regex(new RegExp('${escapedPattern}'))`;
            }
            break;

        case 'number':
            schema = options.enableCoercion ? 'z.coerce.number()' : 'z.number()';
            if (param.integer) {
                schema += '.int()';
            }
            if (param.min !== undefined) {
                schema += `.min(${param.min})`;
            }
            if (param.max !== undefined) {
                schema += `.max(${param.max})`;
            }
            break;

        case 'boolean':
            schema = options.enableCoercion ? 'z.coerce.boolean()' : 'z.boolean()';
            break;

        case 'enum':
            if (!param.values || param.values.length === 0) {
                console.error(`Error: Enum parameter has no values defined. This will cause validation issues.`);
                throw new Error(`Enum parameter must have values array defined`);
            } else {
                const values = param.values.map(v => `"${v}"`).join(', ');
                schema = `z.enum([${values}])`;
            }
            break;

        case 'array':
            schema = 'z.array(z.unknown())';
            break;

        case 'object':
            schema = 'z.record(z.string(), z.unknown())';
            break;

        default:
            schema = 'z.unknown()';
    }

    // Add default value if specified
    if (param.default !== undefined) {
        if (typeof param.default === 'string') {
            schema += `.default("${param.default}")`;
        } else {
            schema += `.default(${JSON.stringify(param.default)})`;
        }
    }

    // Add optional modifier if not required
    if (!param.required) {
        schema += '.optional()';
    }

    return schema;
}

/**
 * Convert script metadata to Zod schema code
 */
export function metadataToZodSchema(
    metadata: ScriptMetadata,
    options: GenerationOptions = {}
): string {
    const params = metadata.params || {};
    const paramEntries = Object.entries(params);

    if (paramEntries.length === 0) {
        return 'z.object({}).strict()';
    }

    const lines: string[] = [];
    lines.push('z.object({');

    for (const [name, param] of paramEntries) {
        const schema = paramToZodSchema(param, options);
        lines.push(`  ${name}: ${schema},`);
    }

    lines.push('}).strict()');

    return lines.join('\n');
}

/**
 * Generate the complete schemas file from manifest
 */
export function generateAllSchemas(
    manifest: ManifestV2,
    options: GenerationOptions = {}
): string {
    const lines: string[] = [];

    // Add header
    lines.push('// Generated by generate-zod-schemas.ts');
    lines.push(`// Generated on: ${new Date().toISOString().split('T')[0]}`);
    lines.push('// DO NOT EDIT MANUALLY - This file is auto-generated from script metadata');
    lines.push('');
    lines.push('import { z } from "zod";');
    lines.push('');

    // Generate schemas object
    lines.push('/**');
    lines.push(' * Zod schemas for all VSC-Bridge scripts');
    lines.push(' * Auto-generated from script metadata files');
    lines.push(' */');
    lines.push('export const scriptSchemas = {');

    for (const [alias, scriptData] of Object.entries(manifest.scripts)) {
        const schema = metadataToZodSchema(scriptData.metadata, options);
        // Indent the schema properly
        const indentedSchema = schema
            .split('\n')
            .map((line, i) => i === 0 ? line : `  ${line}`)
            .join('\n');

        lines.push(`  "${alias}": ${indentedSchema},`);
        lines.push('');
    }

    lines.push('} as const;');
    lines.push('');

    // Add TypeScript utility types
    lines.push('/**');
    lines.push(' * TypeScript type for the schemas object');
    lines.push(' */');
    lines.push('export type ScriptSchemas = typeof scriptSchemas;');
    lines.push('');
    lines.push('/**');
    lines.push(' * Extract the parameter type for a specific script');
    lines.push(' */');
    lines.push('export type ScriptParams<T extends keyof ScriptSchemas> = z.infer<ScriptSchemas[T]>;');
    lines.push('');
    lines.push('/**');
    lines.push(' * Validate parameters for a script');
    lines.push(' */');
    lines.push('export function validateScriptParams<T extends keyof ScriptSchemas>(');
    lines.push('  scriptAlias: T,');
    lines.push('  params: unknown');
    lines.push('): ScriptParams<T> {');
    lines.push('  const schema = scriptSchemas[scriptAlias];');
    lines.push('  if (!schema) {');
    lines.push('    throw new Error(`No schema found for script: ${scriptAlias}`);');
    lines.push('  }');
    lines.push('  return schema.parse(params) as ScriptParams<T>;');
    lines.push('}');
    lines.push('');
    lines.push('/**');
    lines.push(' * Safely validate parameters for a script');
    lines.push(' */');
    lines.push('export function safeValidateScriptParams<T extends keyof ScriptSchemas>(');
    lines.push('  scriptAlias: T,');
    lines.push('  params: unknown');
    lines.push('): { success: true; data: ScriptParams<T> } | { success: false; error: z.ZodError } {');
    lines.push('  const schema = scriptSchemas[scriptAlias];');
    lines.push('  if (!schema) {');
    lines.push('    // Return success for unknown scripts (Tier 3: pass-through)');
    lines.push('    return {');
    lines.push('      success: true,');
    lines.push('      data: params as ScriptParams<T>');
    lines.push('    };');
    lines.push('  }');
    lines.push('  const result = schema.safeParse(params);');
    lines.push('  if (result.success) {');
    lines.push('    return { success: true, data: result.data as ScriptParams<T> };');
    lines.push('  } else {');
    lines.push('    return { success: false, error: result.error };');
    lines.push('  }');
    lines.push('}');

    return lines.join('\n');
}

/**
 * Main function to run the generator
 */
async function main() {
    const manifestPath = path.join(__dirname, '..', 'src', 'vsc-scripts', 'manifest.json');
    const outputPath = path.join(__dirname, '..', 'src', 'vsc-scripts', 'generated', 'schemas.ts');

    // Read manifest
    const manifestContent = fs.readFileSync(manifestPath, 'utf-8');
    const manifest: ManifestV2 = JSON.parse(manifestContent);

    // Generate schemas with coercion enabled for runtime use
    const schemasCode = generateAllSchemas(manifest, { enableCoercion: true });

    // Ensure output directory exists
    const outputDir = path.dirname(outputPath);
    if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
    }

    // Write schemas file
    fs.writeFileSync(outputPath, schemasCode, 'utf-8');

    console.log(`âœ… Generated Zod schemas for ${Object.keys(manifest.scripts).length} scripts`);
    console.log(`   Output: ${outputPath}`);
}

// Run if called directly
if (require.main === module) {
    main().catch(error => {
        console.error('Error generating schemas:', error);
        process.exit(1);
    });
}